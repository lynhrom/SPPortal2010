<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SharepointCommon</name>
    </assembly>
    <members>
        <member name="T:SharepointCommon.Attributes.AsyncAttribute">
            <summary>
            Mark <see cref="T:SharepointCommon.ListEventReceiver`1"/> methods to
            set event receiver is synchronous or asynchronous
            </summary>
        </member>
        <member name="T:SharepointCommon.Attributes.SequenceAttribute">
            <summary>
            Mark <see cref="T:SharepointCommon.ListEventReceiver`1"/> methods to
            set event receiver sequence.
            </summary>
        </member>
        <member name="T:SharepointCommon.Attributes.ListAttribute">
            <summary>
            Attribute used to mark IQueryList properties in <see cref="!:AppBase"/> derived objects.
            Indicates that property must be initialized as SharePoint list
            </summary>
        </member>
        <member name="T:SharepointCommon.Attributes.NotMappedAttribute">
            <summary>
            Attribute, used to mark framework properties when it not mapped to SharePoint objects
            </summary>
        </member>
        <member name="T:SharepointCommon.Attributes.FieldAttribute">
            <summary>
            Attribute, used on entity property to provide additional info about mapped field
            </summary>
        </member>
        <member name="M:SharepointCommon.Attributes.FieldAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SharepointCommon.Attributes.FieldAttribute"/> class.
            </summary>
        </member>
        <member name="M:SharepointCommon.Attributes.FieldAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SharepointCommon.Attributes.FieldAttribute"/> class.
            </summary>
            <param name="name">The inner of field. Used if display name not math with internal name.</param>
        </member>
        <member name="P:SharepointCommon.Attributes.FieldAttribute.Name">
            <summary>
            Internal name of field
            </summary>
        </member>
        <member name="P:SharepointCommon.Attributes.FieldAttribute.DisplayName">
            <summary>
            Display name of field
            Used to rename field after it created with internal name(ex: localized name)
            </summary>
        </member>
        <member name="P:SharepointCommon.Attributes.FieldAttribute.LookupList">
            <summary>
            Gets or sets the name, url, or id of list, referenced by lookup field.
            </summary>
        </member>
        <member name="P:SharepointCommon.Attributes.FieldAttribute.LookupField">
            <summary>
            Gets or sets the name of field, used to display lookup name.
            </summary>
        </member>
        <member name="P:SharepointCommon.Attributes.FieldAttribute.IsMultilineText">
            <summary>
            Gets or sets a value indicating whether 'Text' field is multiline('Note')
            </summary>
            <value>
            <c>true</c> if this instance is multiline text; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:SharepointCommon.Attributes.FieldAttribute.Required">
            <summary>
            Gets or sets a value indicating whether field is required
            </summary>
            <value>
            <c>true</c> if this field is required; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:SharepointCommon.Attributes.FieldAttribute.DefaultValue">
            <summary>
            Gets or sets a value used as default for field
            </summary>
        </member>
        <member name="T:SharepointCommon.Attributes.ContentTypeAttribute">
            <summary>
            Attribute used to mark entity, which represents content types
            </summary>
        </member>
        <member name="M:SharepointCommon.Attributes.ContentTypeAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SharepointCommon.Attributes.ContentTypeAttribute"/> class.
            </summary>
            <param name="contentTypeId">The content type id.</param>
        </member>
        <member name="P:SharepointCommon.Attributes.ContentTypeAttribute.ContentTypeId">
            <summary>
            Id of content type
            </summary>
        </member>
        <member name="T:SharepointCommon.Attributes.NamespaceDoc">
            <summary>
            Contains attributes used in framework
            </summary>
        </member>
        <member name="T:SharepointCommon.Attributes.NotFieldAttribute">
            <summary>
            Attribute, used to mark entity property when it not mapped to SharePoint field
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SharepointCommon.Common.CommonHelper.ImplementsInterface(System.Type,System.Type)" -->
        <!-- Badly formed XML comment ignored for member "M:SharepointCommon.Common.CommonHelper.ImplementsOpenGenericInterface(System.Type,System.Type)" -->
        <member name="M:SharepointCommon.Common.FieldMapper.IsReadOnlyField(System.String)">
            <summary>
            read method name as: IsNotReadOnlyField. Must been refactored later
            </summary>
        </member>
        <member name="T:SharepointCommon.Events.ListItemEventReceiver">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="T:SharepointCommon.AppBase`1">
            <summary>
            Base class for derive 'Application' objects from it.
            By inherit class from 'AppBase' you gain possibility
            to map auto-properties of list wrappers to SharePoint lists
            </summary>
             
            <example> 
            <![CDATA[
            public class TestApp : AppBase<TestApp>
            { 
                [List(Url="lists/contract")]
                public virtual IQueryList<Contract> Contracts { get; }
            }
            
            using (var app01 = TestApp.Factory.OpenNew(_webUrl))
            {
                var contractsList = app01.Contracts;
            }
            ]]>
            </example> 
            <typeparam name="T">Type of your class derived from AppBase</typeparam>
        </member>
        <member name="P:SharepointCommon.AppBase`1.Factory">
            <summary>
            Gets factory instance for creating
            <see cref="!:AppBase"/> derived objects
            </summary>
        </member>
        <member name="P:SharepointCommon.AppBase`1.QueryWeb">
            <summary>
            Gets underlying <see cref="T:SharepointCommon.IQueryWeb"/> object
            </summary>
        </member>
        <member name="P:SharepointCommon.AppBase`1.UserInfoList">
            <summary>
            Instance of IQueryList associated with SharePoint 'User Information List' list
            </summary>
        </member>
        <member name="P:SharepointCommon.AppBase`1.ShouldDispose">
            <summary>
            If true, call Dispose method on <see cref="P:SharepointCommon.AppBase`1.QueryWeb"/> when disposing itself
            </summary>
        </member>
        <member name="M:SharepointCommon.AppBase`1.Init">
            <summary>
            Method that called after object initialization complete
            </summary>
        </member>
        <member name="T:SharepointCommon.Entities.Category">
            <summary>
            Enumeration for content type 'Holiday' field 'Category'
            </summary>
        </member>
        <member name="T:SharepointCommon.Entities.Form">
            <summary>
            Represents an item with content type 'Form' in SharePoint list
            </summary>
        </member>
        <member name="T:SharepointCommon.Entities.Holiday">
            <summary>
            Represents an item with content type 'Holiday' in SharePoint list
            </summary>
        </member>
        <member name="T:SharepointCommon.Entities.Announcement">
            <summary>
            Represents an item with content type 'Announcement' in SharePoint list
            </summary>
        </member>
        <member name="T:SharepointCommon.Entities.NamespaceDoc">
            <summary>
            Contains types used to represent list items and content types
            </summary>
        </member>
        <member name="M:SharepointCommon.ItemExtention.GetFieldName``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Gets inner name of underlying mapped SPField
            </summary>
            <typeparam name="T">type of entity</typeparam>
            <param name="self">instance of entity</param>
            <param name="fieldSelector">expression to select entity property which inner name need get</param>
            <returns>inner name of underlying mapped SPField</returns>
        </member>
        <member name="M:SharepointCommon.ItemExtention.GetChoice``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Gets Name property of FieldAttribute if marked with
            </summary>
            <typeparam name="T">type of entity</typeparam>
            <param name="self">instance of entity</param>
            <param name="fieldSelector">expression to select entity property which text need get</param>
            <returns>Name property of FieldAttribute</returns>
        </member>
        <member name="M:SharepointCommon.ItemExtention.SetChoice``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Sets choice property by a text used in FieldAttribute.Name
            </summary>
            <typeparam name="T">type of entity</typeparam>
            <param name="self">instance of entity</param>
            <param name="fieldSelector">expression to select entity property which value need set</param>
            <param name="value">text used in FieldAttribute.Name</param>
        </member>
        <member name="M:SharepointCommon.ItemExtention.FormUrl(SharepointCommon.Item,SharepointCommon.PageType,System.Boolean)">
            <summary>
            Gets display form url for item
            </summary>
        </member>
        <member name="T:SharepointCommon.CamlQuery">
            <summary>
            Class used to represent query to SharePoint list, such CAML query, ViewFields and etc.
            </summary>
        </member>
        <member name="P:SharepointCommon.CamlQuery.Default">
            <summary>
            Gets the default query, that return all items with all view fields
            </summary>
        </member>
        <member name="M:SharepointCommon.CamlQuery.ViewFields(System.String[])">
            <summary>
            Sets ViewFields used in CAML query
            </summary>
            <param name="viewFields">The view field names (not xml tags!).</param>
            <returns>Fluent instance of that class</returns>
        </member>
        <member name="M:SharepointCommon.CamlQuery.ViewFields``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}}[])">
            <summary>
            Sets ViewFields used in CAML query
            </summary>
            <param name="selectors">Expressions indicates properties used as view fields</param>
            <returns>Fluent instance of that class</returns>
        </member>
        <member name="M:SharepointCommon.CamlQuery.Recursive">
            <summary>
            Indicates that CAML query affects items in subfolders
            </summary>
            <returns>Fluent instance of that class</returns>
        </member>
        <member name="M:SharepointCommon.CamlQuery.RowLimit(System.Int32)">
            <summary>
            Sets limit of rows, returned by CAML query
            </summary>
            <param name="rowlimit"></param>
            <returns>Fluent instance of that class</returns>
        </member>
        <member name="M:SharepointCommon.CamlQuery.Folder(System.String)">
            <summary>
            Sets folder url, used in CAML query
            </summary>
            <param name="url"></param>
            <returns>Fluent instance of that class</returns>
        </member>
        <member name="M:SharepointCommon.CamlQuery.Query(System.String)">
            <summary>
            Sets CAML query text. Use '<see cref="T:SharepointCommon.Q"/>' class to construct query
            </summary>
            <param name="caml">The caml.</param>
            <returns>Fluent instance of that class</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:SharepointCommon.Document" -->
        <member name="P:SharepointCommon.Document.Name">
            <summary>
            Gets or sets the name of file in document library.
            </summary>
            <value>
            The name of file.
            </value>
        </member>
        <member name="P:SharepointCommon.Document.Content">
            <summary>
            Gets or sets the content of file in document library.
            </summary>
            <value>
            The content of file.
            </value>
        </member>
        <member name="P:SharepointCommon.Document.Size">
            <summary>
            Gets the size of file in document library.
            </summary>
        </member>
        <member name="P:SharepointCommon.Document.Icon">
            <summary>
            Gets the url, represents image used as icon for file in document library.
            </summary>
        </member>
        <member name="P:SharepointCommon.Document.Url">
            <summary>
            Gets the URL of file in document library.
            </summary>
        </member>
        <member name="P:SharepointCommon.Document.RenameIfExists">
            <summary>
            Gets or sets a value indicating whether file need be rename (ex. should have index "report(1).doc" )
            if file with same name already exists in specified folder.
            </summary>
            <value>
            <c>true</c> if [rename if exists]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:SharepointCommon.ListEventReceiver`1">
            <summary>
            Base class to inherit list event receivers.
            Need to override methods to hook events.
            Methods can be marked with attributes:
            <see cref="T:SharepointCommon.Attributes.AsyncAttribute"/>,
            <see cref="T:SharepointCommon.Attributes.SequenceAttribute"/>,
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:SharepointCommon.Field">
            <summary>
            Represents a SharePoint field
            </summary>
        </member>
        <member name="P:SharepointCommon.Field.Id">
            <summary>
            Gets or sets the field id.
            </summary>
            <value>
            The id.
            </value>
        </member>
        <member name="P:SharepointCommon.Field.Name">
            <summary>
            Gets or sets field name.
            </summary>
            <value>
            The name.
            </value>
        </member>
        <member name="P:SharepointCommon.Field.DisplayName">
            <summary>
            Gets or sets field display name.
            </summary>
            <value>
            The display name.
            </value>
        </member>
        <member name="P:SharepointCommon.Field.Type">
            <summary>
            Gets or sets the type of field.
            </summary>
            <value>
            The type.
            </value>
        </member>
        <member name="P:SharepointCommon.Field.IsMultiValue">
             <summary>
             Gets or sets a value indicating whether field support multi-value.
             </summary>
             <value>
            <c>true</c> if this instance is multi value; otherwise, <c>false</c>.
             </value>
        </member>
        <member name="P:SharepointCommon.Field.LookupList">
            <summary>
            Gets or sets the name of the lookup list which referenced by lookup field.
            </summary>
            <value>
            The name, url or id of the lookup list.
            </value>
        </member>
        <member name="P:SharepointCommon.Field.LookupField">
            <summary>
            Gets or sets the field used to display lookup.
            </summary>
            <value>
            The lookup field.
            </value>
        </member>
        <member name="P:SharepointCommon.Field.Required">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:SharepointCommon.Field"/> is required.
            </summary>
            <value>
              <c>true</c> if required; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:SharepointCommon.Field.Choices">
            <summary>
            Gets or sets the choices used to represent 'Choice' field.
            </summary>
            <value>
            The choices.
            </value>
        </member>
        <member name="P:SharepointCommon.Field.DefaultValue">
            <summary>
            Gets or sets default value for field
            </summary>
        </member>
        <member name="T:SharepointCommon.IAppFac`1">
            <summary>
            Factory for produce 'AppBase' derived objects
            </summary>
            <typeparam name="T">Type of class derived from AppBase</typeparam>
        </member>
        <member name="M:SharepointCommon.IAppFac`1.ExistingWeb(SharepointCommon.IQueryWeb)">
            <summary>
            Create object based on existing <see cref="T:SharepointCommon.IQueryWeb"/> queryWeb
            </summary>
            <returns>AppBase derived object of type T</returns>
        </member>
        <member name="M:SharepointCommon.IAppFac`1.ExistingWeb(Microsoft.SharePoint.SPWeb)">
            <summary>
            Create object based on existing <see cref="!:SPWeb"/> queryWeb
            </summary>
            <returns>AppBase derived object of type T</returns>
        </member>
        <member name="M:SharepointCommon.IAppFac`1.CurrentContext">
            <summary>
            Create object based on SPContext.Current
            </summary>
            <returns>AppBase derived object of type T</returns>
        </member>
        <member name="M:SharepointCommon.IAppFac`1.ElevatedFromCurrentContext">
            <summary>
            Create object based on SPContext.Current with elevate permissions
            </summary>
            <returns>AppBase derived object of type T</returns>
        </member>
        <member name="M:SharepointCommon.IAppFac`1.OpenNew(System.String)">
            <summary>
            Create new object by site url. Must call Dispose method or be in using clause
            </summary>
            <returns>AppBase derived object of type T</returns>
        </member>
        <member name="M:SharepointCommon.IAppFac`1.OpenNew(System.Guid,System.Guid)">
            <summary>
            Create new object by site id and web id. Must call Dispose method or be in using clause
            </summary>
            <returns>AppBase derived object of type T</returns>
        </member>
        <member name="M:SharepointCommon.IAppFac`1.ElevatedNew(System.String)">
            <summary>
            Create new object in elevated mode by site url. Must call Dispose method or be in using clause
            </summary>
            <returns>AppBase derived object of type T</returns>
        </member>
        <member name="M:SharepointCommon.IAppFac`1.ElevatedNew(System.Guid,System.Guid)">
            <summary>
            Create new object by site id and web id in elevated mode. Must call Dispose method or be in using clause
            </summary>
            <returns>AppBase derived object of type T</returns>
        </member>
        <member name="T:SharepointCommon.Mapper">
            <summary>
            Allow perform listitem to entity mapping
            </summary>
        </member>
        <member name="M:SharepointCommon.Mapper.ToEntity``1(Microsoft.SharePoint.SPListItem)">
            <summary>
            Map SPListItem to SharePointCommon.Item by one row of code
            </summary>
            <typeparam name="T"></typeparam>
            <param name="listItem"></param>
            <returns></returns>
        </member>
        <member name="T:SharepointCommon.SharepointCommonException">
            <summary>
            General exception, thrown by 'SharepointCommon' in different error situations.
            </summary>
        </member>
        <member name="M:SharepointCommon.SharepointCommonException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SharepointCommon.SharepointCommonException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:SharepointCommon.Q">
            <summary>
            A helper class for working with CAML queries.
            </summary>
        </member>
        <member name="M:SharepointCommon.Q.Tag(System.String,System.String,System.String,System.String)">
            <summary>
            Builds an XML string with or without attributes and attribute values.
            </summary>
            <param name="tag">the XML element tag</param>
            <param name="attribute">the attribute name (can be null)</param>
            <param name="attributeValue">the attribute value (can be null)</param>
            <param name="value">the element value (can be null)</param>
            <returns>an XML string resulting from the combined parameters</returns>
        </member>
        <member name="M:SharepointCommon.Q.Tag(System.String,System.String,System.Object[])">
            <summary>
            Handles an arbitrary number of attribute value pairs
            </summary>
            <param name="tag">the XML element tag</param>
            <param name="value">the element value</param>
            <param name="attributeValuePairs">an array of attribute value pairs</param>
            <returns>an XML string resulting from the combined parameters</returns>
        </member>
        <member name="T:SharepointCommon.Q.SortType">
            <summary>
            Use this enumeration to specify sorting of field elements.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.SortType.Ascending">
            <summary>
            Items are sorted in ascending order.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.SortType.Descending">
            <summary>
            Items are sorted in descending order.
            </summary>
        </member>
        <member name="T:SharepointCommon.Q.MembershipType">
            <summary>
            Use this enumeration to specify membership types.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.MembershipType.SPWebAllUsers">
            <summary>
            Returns all users who are either members of the site or who have browsed to the site as authenticated members of a domain group in the site.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.MembershipType.SPGroup">
            <summary>
            Returns groups in the site collection.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.MembershipType.SPWebGroups">
            <summary>
            Returns groups in the SharePoint web.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.MembershipType.CurrentUserGroups">
            <summary>
            Returns 
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.MembershipType.SPWebUsers">
            <summary>
            Returns all users that have been explicitly added to the web.
            </summary>
        </member>
        <member name="T:SharepointCommon.Q.BaseType">
            <summary>
            Use this enumeration to specify the base list type for cross site queries.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.BaseType.GenericList">
            <summary>
            A generic list.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.BaseType.DocumentLibrary">
            <summary>
            A document library.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.BaseType.DiscussionForum">
            <summary>
            A discussion forum.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.BaseType.VoteOrSurvey">
            <summary>
            A survey list.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.BaseType.IssuesList">
            <summary>
            An issue tracking list.
            </summary>
        </member>
        <member name="T:SharepointCommon.Q.QueryScope">
            <summary>
            Use this enumeration to specify the scope of a site data query.
            </summary>
            
        </member>
        <member name="F:SharepointCommon.Q.QueryScope.WebOnly">
            <summary>
            The query considers only the current SPWeb object.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.QueryScope.Recursive">
            <summary>
            The query considers all Web sites that are descended from the current SPWeb object.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.QueryScope.SiteCollection">
            <summary>
            The query considers all Web sites that are in the same site collection as the current Web site.
            </summary>
        </member>
        <member name="M:SharepointCommon.Q.And(System.String,System.String)">
            <summary>
            Specifies the logical conjunction of two CAML clauses.
            </summary>
            <param name="leftPart">the left part of the join</param>
            <param name="rightPart">the right part of the join</param>
            <returns>a new CAML And element</returns>
        </member>
        <member name="M:SharepointCommon.Q.BeginsWith(System.String,System.String)">
            <summary>
            Specifies that the value of a given field begins with the specified value.
            </summary>
            <param name="fieldRefElement">a CAML FieldRef element</param>
            <param name="valueElement">a CAML Value element</param>
            <returns>a new CAML BeginsWith element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Contains(System.String,System.String)">
            <summary>
            Specifies that the value of a given field contains the specified value.
            </summary>
            <param name="fieldRefElement">a CAML FieldRef element</param>
            <param name="valueElement">a CAML Value element</param>
            <returns>a new CAML Contains element</returns>
        </member>
        <member name="M:SharepointCommon.Q.DateRangesOverlap(System.String,System.String)">
            <summary>
            Tests whether the dates in a recurring event overlap a specified DateTime value.
            </summary>
            <param name="fieldRefElement">a CAML FieldRef element for the target event date</param>
            <param name="valueElement">a CAML Value element containing the date to be tested</param>
            <returns>a new CAML DateRangesOverlap element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Eq(System.String,System.String)">
            <summary>
            Tests the equality of two CAML clauses.
            </summary>
            <param name="leftPart">the left part of the expression</param>
            <param name="rightPart">the right part of expression</param>
            <returns>a new CAML EQ element</returns>
        </member>
        <member name="M:SharepointCommon.Q.FieldRef(System.String)">
            <summary>
            Identifies a CAML field by reference.
            </summary>
            <param name="fieldName">the name of the referenced field</param>
            <returns>a new CAML FieldRef element</returns>
        </member>
        <member name="M:SharepointCommon.Q.FieldRef(System.String,SharepointCommon.Q.SortType)">
            <summary>
            Identifies a CAML field and specifies a sorting.
            </summary>
            <param name="fieldName">the name of the referenced field</param>
            <param name="sortType">indicates how the resulting field instances shall be sorted</param>
            <returns>a new CAML FieldRef element with sorting</returns>
        </member>
        <member name="M:SharepointCommon.Q.FieldRef(System.String,System.Boolean)">
            <summary>
            Identifies a CAML field and specifies LookupId attribute if needed.
            </summary>
            <param name="fieldName">the name of the referenced field</param>
            <param name="lookupId">indicates whether to add LookupId attribute to FieldRef clause</param>
            <returns>a new CAML FieldRef element </returns>
        </member>
        <member name="M:SharepointCommon.Q.FieldRef``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Identifies a CAML field by reference.
            </summary>
            <param name="selector">expression for property selection, example: i => t.Title</param>
            <typeparam name="T">type of entity</typeparam>
            <returns>a new CAML FieldRef element</returns>
        </member>
        <member name="M:SharepointCommon.Q.FieldRef``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},SharepointCommon.Q.SortType)">
            <summary>
            Identifies a CAML field and specifies a sorting.
            </summary>
            <param name="selector">expression for property selection, example: i => t.Title</param>
            <param name="sortType">indicates how the resulting field instances shall be sorted</param>
            <typeparam name="T">type of entity</typeparam>
            <returns>a new CAML FieldRef element with sorting</returns>
        </member>
        <member name="M:SharepointCommon.Q.FieldRef``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Boolean)">
            <summary>
            Identifies a CAML field and specifies LookupId attribute if needed.
            </summary>
            <param name="selector">expression for property selection, example: i => t.Title</param>
            <param name="lookupId">indicates whether to add LookupId attribute to FieldRef clause</param>
            <typeparam name="T">type of entity</typeparam>
            <returns>a new CAML FieldRef element </returns>
        </member>
        <member name="M:SharepointCommon.Q.Geq(System.String,System.String)">
            <summary>
            Tests whether the left expression is greater than or equal to the right.
            </summary>
            <param name="leftPart">the left expression</param>
            <param name="rightPart">the right expression</param>
            <returns>a new CAML GEQ element</returns>
        </member>
        <member name="M:SharepointCommon.Q.GroupBy(System.String)">
            <summary>
            Identifies a field reference for grouping.
            </summary>
            <param name="fieldRefElement">a CAML FieldRef element</param>
            <returns>a new CAML GroupBy element</returns>
        </member>
        <member name="M:SharepointCommon.Q.GroupBy(System.String,System.Boolean)">
            <summary>
            Identifies a field reference for grouping and specifies whether to collapse the group.
            </summary>
            <param name="fieldRefElement">a CAML FieldRef element</param>
            <param name="bCollapse">whether to collapse the group</param>
            <returns>a new CAML GroupBy element</returns>
        </member>
        <member name="M:SharepointCommon.Q.In(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Builds an In element from a fieldRef element and array of values.
            </summary>
            <param name="fieldRefElement">a CAML FieldRef element</param>
            <param name="valueType">a string describing the data type</param>
            <param name="fieldValues">an IEnumerable of values each formatted as a string</param>
            <returns>a new CAML In element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Gt(System.String,System.String)">
            <summary>
            Tests whether the left expression is greater than the right.
            </summary>
            <param name="leftPart">the left expression</param>
            <param name="rightPart">the right expression</param>
            <returns>a new CAML GT element</returns>
        </member>
        <member name="M:SharepointCommon.Q.IsNotNull(System.String)">
            <summary>
            Determines whether a given field contains a value.
            </summary>
            <param name="fieldRefElement">a CAML FieldRef element</param>
            <returns>a new CAML IsNotNull element</returns>
        </member>
        <member name="M:SharepointCommon.Q.IsNull(System.String)">
            <summary>
            Determines whether a given field is null.
            </summary>
            <remarks>Converse of IsNotNull</remarks>
            <param name="fieldRefElement">a CAML FieldRef element</param>
            <returns>a new CAML IsNull element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Leq(System.String,System.String)">
            <summary>
            Tests whether the left expression is less than or equal to the right.
            </summary>
            <param name="leftPart">the left expression</param>
            <param name="rightPart">the right expression</param>
            <returns>a new CAML LEQ element</returns>
        </member>
        <member name="M:SharepointCommon.Q.SafeIdentifier(System.String)">
            <summary>
            Creates a "safe" identifier for use in CAML expressions.
            </summary>
            <remarks>
            This method replaces blank spaces with the "_x0020_" token.
            </remarks>
            <param name="identifier">the identifier to be tokenized</param>
            <returns>a tokenized version of the identifier</returns>
        </member>
        <member name="M:SharepointCommon.Q.List(System.Guid)">
            <summary>
            Allows a query to include specific lists, instead of returning all lists of a particular type.
            </summary>
            <param name="listId">identifies the lists</param>
        </member>
        <member name="M:SharepointCommon.Q.Lists(System.String)">
            <summary>
            Specifies which lists to include in a query.
            </summary>
            <param name="listElements">an XML string containing individual list elements</param>
        </member>
        <member name="M:SharepointCommon.Q.Lists(System.String,System.Boolean)">
            <summary>
            Specifies which lists to include in a query.
            </summary>
            <param name="listElements">an XML string containing individual list elements</param>
            <param name="includeHiddenLists">determines whether the query will include hidden lists</param>
        </member>
        <member name="M:SharepointCommon.Q.Lists(System.String,System.Int32)">
            <summary>
            Specifies which lists to include in a query.
            </summary>
            <param name="listElements">an XML string containing individual list elements</param>
            <param name="maxListLimit">limits the query to the total number of lists specified.  By default, the limit is 1000.</param>
        </member>
        <member name="M:SharepointCommon.Q.Lists(System.String,System.String,System.Boolean)">
            <summary>
            Specifies which lists to include in a query.
            </summary>
            <param name="listElements">an XML string containing individual list elements</param>
            <param name="serverTemplate">limits the query to lists of the specified server template, specified as a number - for example '101'</param>
            <param name="includeHiddenLists">determines whether the query will include hidden lists</param>
        </member>
        <member name="M:SharepointCommon.Q.Lists(SharepointCommon.Q.BaseType,System.String)">
            <summary>
            Specifies which lists to include in a query.
            </summary>
            <param name="baseType">limits the query to lists of the specified base type</param>
            <param name="listElements">an XML string containing individual list elements</param>
        </member>
        <member name="M:SharepointCommon.Q.Lists(SharepointCommon.Q.BaseType,System.String,System.String)">
            <summary>
            Specifies which lists to include in a query.
            </summary>
            <param name="baseType">limits the query to lists of the specified base type</param>
            <param name="listElements">an XML string containing individual list elements</param>
            <param name="serverTemplate">limits the query to lists of the specified server template, specified as a number - for example '101'</param>
        </member>
        <member name="M:SharepointCommon.Q.Lists(SharepointCommon.Q.BaseType,System.String,System.String,System.Boolean)">
            <summary>
            Specifies which lists to include in a query.
            </summary>
            <param name="baseType">limits the query to lists of the specified base type</param>
            <param name="listElements">an XML string containing individual list elements</param>
            <param name="serverTemplate">limits the query to lists of the specified server template, specified as a number - for example '101'</param>
            <param name="includeHiddenLists">determines whether the query will include hidden lists</param>
        </member>
        <member name="M:SharepointCommon.Q.Lists(SharepointCommon.Q.BaseType,System.String,System.String,System.Boolean,System.Int32)">
            <summary>
            Specifies which lists to include in a query.
            </summary>
            <param name="baseType">limits the query to lists of the specified base type</param>
            <param name="listElements">an XML string containing individual list elements</param>
            <param name="serverTemplate">limits the query to lists of the specified server template, specified as a number - for example '101'</param>
            <param name="includeHiddenLists">determines whether the query will include hidden lists</param>
            <param name="maxListLimit">limits the query to the total number of lists specified.  By default, the limit is 1000.</param>
        </member>
        <member name="M:SharepointCommon.Q.WithIndex(System.Guid,System.String)">
            <summary>
            Special optional child of the Lists element.
            </summary>
            <remarks>When present, this element causes the query to be limited to lists
            with indexed fields.</remarks>
            <param name="fieldID">the guid of the indexed field</param>
            <param name="fieldValue">the matching field value</param>
        </member>
        <member name="M:SharepointCommon.Q.Lt(System.String,System.String)">
            <summary>
            Tests whether the left expression is less than the right.
            </summary>
            <param name="leftPart">the left expression</param>
            <param name="rightPart">the right expression</param>
            <returns>a new CAML LT element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Membership(SharepointCommon.Q.MembershipType)">
            <summary>
            Specifies the membership for a query <see cref="T:SharepointCommon.Q.MembershipType"/>.
            </summary>
            <param name="type">specifies the membership type</param>
            <returns>a new CAML Membership element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Membership(SharepointCommon.Q.MembershipType,System.String)">
            <summary>
            Specifies the membership for a query <see cref="T:SharepointCommon.Q.MembershipType"/>
            </summary>
            <param name="type">specifies the membership type</param>
            <param name="value">specifies the membership filter value</param>
            <returns>a new CAML Membership element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Neq(System.String,System.String)">
            <summary>
            Tests whether the left expression is unequal to the right.
            </summary>
            <param name="leftPart">the left expression</param>
            <param name="rightPart">the right expression</param>
            <returns>a new CAML NEQ element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Or(System.String,System.String)">
            <summary>
            Specifies the logical disjunction of two CAML expressions.
            </summary>
            <param name="leftPart">the left part of the logical join</param>
            <param name="rightPart">the right part of the logical join</param>
            <returns>a new CAML OR element</returns>
        </member>
        <member name="M:SharepointCommon.Q.OrderBy(System.String)">
            <summary>
            Specifies the names of fields to be used for ordering the result set.
            </summary>
            <param name="fieldRefElements">a CAML string containing a list of CAML FieldRef elements</param>
            <returns>a new CAML OrderBy element</returns>
        </member>
        <member name="M:SharepointCommon.Q.OrderBy(System.Object[])">
            <summary>
            Builds an OrderBy element from an array of FieldRef elements.
            </summary>
            <param name="args">an array of CAML FieldRef elements</param>
            <returns>a new CAML OrderBy element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Value(System.String)">
            <summary>
            Specifies a string value
            </summary>
            <param name="fieldValue">the string value to be expressed in CAML</param>
            <returns>a new CAML Value element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Value(System.Int32)">
            <summary>
            Specifies an integer value
            </summary>
            <param name="fieldValue">the integer value to be expressed in CAML</param>
            <returns>a new CAML Value element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Value(System.DateTime)">
            <summary>
            Specifies a DateTime value
            </summary>
            <param name="fieldValue">the DateTime value to be expressed in CAML</param>
            <returns>a new CAML Value element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Value(System.Boolean)">
            <summary>
            Specifies a boolean value
            </summary>
            <param name="fieldValue">the boolean value to be expressed in CAML</param>
            <returns>a new CAML Value element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Value(System.String,System.String)">
            <summary>
            Specifies a value of a given type
            </summary>
            <param name="valueType">a string describing the data type</param>
            <param name="fieldValue">the value formatted as a string</param>
            <returns>a new CAML Value element</returns>
        </member>
        <member name="M:SharepointCommon.Q.ViewFields(System.Object[])">
            <summary>
            Specifies which fields to include in the query result set.
            </summary>
            <param name="fields">an array of CAML FieldRef elements that identify the fields to be included</param>
            <returns>a new CAML ViewFields element</returns>
        </member>
        <member name="M:SharepointCommon.Q.Webs(SharepointCommon.Q.QueryScope)">
            <summary>
            Specifies which Web sites to include in the query as specified by the Scope attribute.
            </summary>
            <param name="scope">specifies the query scope</param>
        </member>
        <member name="M:SharepointCommon.Q.ProjectProperty(System.String)">
            <summary>
            Specifies a global site property.
            </summary>
            <param name="propertyName">the name of the property to be retrieved</param>
            <returns>a new CAML ProjectProperty element</returns>
        </member>
        <member name="M:SharepointCommon.Q.ProjectProperty(System.String,System.String)">
            <summary>
            Specifies a global site property and a default value.
            </summary>
            <param name="propertyName">the name of the property to be retrieved</param>
            <param name="defaultValue">the default value to use if the property is not found</param>
            <returns>a new CAML ProjectProperty element</returns>
        </member>
        <member name="T:SharepointCommon.Q.AutoHyperlinkType">
            <summary>
            Specifies how to handle automatic hyperlinks.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.AutoHyperlinkType.None">
            <summary>
            Hyperlinks are ignored.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.AutoHyperlinkType.Plain">
            <summary>
            Surround text with &lt;A&gt; tags if the text appears like a hyperlink (for example, www.johnholliday.net),
            but without HTML encoding.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.AutoHyperlinkType.HTMLEncoded">
            <summary>
            Surround text with &lt;A&gt; tags if the text appears like a hyperlink, with HTML encoding.
            </summary>
        </member>
        <member name="T:SharepointCommon.Q.UrlEncodingType">
            <summary>
            Specifies options for URL encoding.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.UrlEncodingType.None">
            <summary>
            Special characters are not encoded.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.UrlEncodingType.Standard">
            <summary>
            Convert special characters, such as spaces, to quoted UTF-8 format.
            </summary>
        </member>
        <member name="F:SharepointCommon.Q.UrlEncodingType.EncodeAsUrl">
            <summary>
            Convert special characters to quoted UTF-8 format, but treats the characters as a
            path component of a URL so that forward slashes ("/") are not encoded.
            </summary>
        </member>
        <member name="M:SharepointCommon.Q.ProjectProperty(System.String,System.String,SharepointCommon.Q.AutoHyperlinkType,System.Boolean,System.Boolean,System.Boolean,System.Boolean,SharepointCommon.Q.UrlEncodingType)">
            <summary>
            Specifies a global site property and other options.
            </summary>
            <param name="propertyName">the name of the property to be retrieved</param>
            <param name="defaultValue">the default value to use if the property is not found</param>
            <param name="autoHyperlinkType">specifies how to handle hyperlinks <see cref="T:SharepointCommon.Q.AutoHyperlinkType"/></param>
            <param name="autoNewLine">TRUE to insert &lt;BR&gt; tags into the text stream and to replace multiple spaces with a nonbreaking space.</param>
            <param name="expandXML">TRUE to re-pass the rendered content through the CAML interpreter, which allows CAML to render CAML.</param>
            <param name="htmlEncode">TRUE to convert embedded characters so that they are displayed as text in the browser.  In other words, characters that could be confused with HTML tags are converted to entities.</param>
            <param name="stripWhiteSpace">TRUE to remove white space from the beginning and end of the value returned by the element.</param>
            <param name="urlEncodingType">specifies how to handle URL encoding <see cref="T:SharepointCommon.Q.UrlEncodingType"/></param>
            <returns></returns>
        </member>
        <member name="M:SharepointCommon.Q.Where(System.String)">
            <summary>
            Specifies the WHERE part of a query.
            </summary>
            <param name="s">a CAML string that expresses the WHERE conditions</param>
            <returns>a new CAML Where element</returns>
        </member>
        <member name="M:SharepointCommon.Q.XML(System.String)">
            <summary>
            Specifies a custom XML element.
            </summary>
            <param name="s">a CAML string to be embedded in the element</param>
            <returns>a new CAML XML element</returns>
        </member>
        <member name="T:SharepointCommon.Item">
            <summary>
            Base entity for present SPList item of content type 'Item'
            Used as root of inheritance for all custom entities and content types
            </summary>
        </member>
        <member name="P:SharepointCommon.Item.Folder">
            <summary>
            Gets or sets the folder of file in document library.
            While upload new file, it puts in specified folder.
            </summary>
            <value>
            The relative folder URL. Ex: folder1/folder2/folder3
            </value>
        </member>
        <member name="P:SharepointCommon.Item.ParentList">
            <summary>
            Gets the reference to item's parent list.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:SharepointCommon.Item.ConcreteParentList" -->
        <member name="P:SharepointCommon.Item.ListItem">
            <summary>
            Gets the reference to underlying list item
            </summary>
        </member>
        <member name="M:SharepointCommon.Item.GetFieldName``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Gets inner name of underlying mapped SPField
            </summary>
            <typeparam name="T">type of entity property which inner name need get</typeparam>
            <param name="fieldSelector">expression to select entity property which inner name need get</param>
            <returns>inner name of underlying mapped SPField</returns>
        </member>
        <member name="T:SharepointCommon.NamespaceDoc">
            <summary>
            Contains most general classes to work with framework
            </summary>
        </member>
        <member name="T:SharepointCommon.PageType">
            <summary>
            Type of used page
            </summary>
        </member>
        <member name="F:SharepointCommon.PageType.Display">
            <summary>
            ListItem display form
            </summary>
        </member>
        <member name="F:SharepointCommon.PageType.Edit">
            <summary>
            ListItem edit form
            </summary>
        </member>
        <member name="F:SharepointCommon.PageType.New">
            <summary>
            ListItem create form
            </summary>
        </member>
        <member name="T:SharepointCommon.Person">
            <summary>
            Presents value for a 'User or Group' list item field
            Used for domain user or group returns 'Person' object, but entity mapping should use only 'User' type
            </summary>
        </member>
        <member name="M:SharepointCommon.Person.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SharepointCommon.Person"/> class.
            </summary>
        </member>
        <member name="M:SharepointCommon.Person.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SharepointCommon.Person"/> class.
            </summary>
            <param name="login">domain user or group login</param>
        </member>
        <member name="P:SharepointCommon.Person.Email">
            <summary>
            domain user or group e-mail
            </summary>
        </member>
        <member name="P:SharepointCommon.Person.Login">
            <summary>
            domain user or group login
            </summary>
        </member>
        <member name="T:SharepointCommon.IQueryList`1">
            <summary>
            Represents wrapper on a SharePoint list or library
            </summary>
            <typeparam name="T">Item or ContentType of list item</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "P:SharepointCommon.IQueryList`1.ParentWeb" -->
        <member name="P:SharepointCommon.IQueryList`1.List">
            <summary>
            Gets underlying list instance
            </summary>
        </member>
        <member name="P:SharepointCommon.IQueryList`1.Id">
            <summary>
            Gets the SPList id.
            </summary>
        </member>
        <member name="P:SharepointCommon.IQueryList`1.WebId">
            <summary>
            Gets the SPWeb id.
            </summary>
        </member>
        <member name="P:SharepointCommon.IQueryList`1.SiteId">
            <summary>
            Gets the SPSite id.
            </summary>
        </member>
        <member name="P:SharepointCommon.IQueryList`1.Title">
            <summary>
            Gets or sets the SPList title.
            </summary>
            <value>
            The title.
            </value>
        </member>
        <member name="P:SharepointCommon.IQueryList`1.IsVersioningEnabled">
            <summary>
            Gets or sets a value indicating whether this list is versioning enabled.
            </summary>
            <value>
            <c>true</c> if this list is versioning enabled; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:SharepointCommon.IQueryList`1.IsFolderCreationAllowed">
            <summary>
            Gets or sets a value indicating whether this list is folder creation allowed.
            </summary>
            <value>
            <c>true</c> if this list is folder creation allowed; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:SharepointCommon.IQueryList`1.AllowManageContentTypes">
            <summary>
            Gets or sets a value indicating whether list allows to manage content types.
            </summary>
            <value>
            <c>true</c> if list allows manage content types; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:SharepointCommon.IQueryList`1.Url">
            <summary>
            Gets the full url of list. Ex: http://server/lists/list1
            </summary>
        </member>
        <member name="P:SharepointCommon.IQueryList`1.RelativeUrl">
            <summary>
            Gets the relative url of list. Ex: /lists/list1
            </summary>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.AddEventReceiver``1">
            <summary>
            Registers list event receiver
            </summary>
            <typeparam name="TEventReceiver">Type inherited from <see cref="T:SharepointCommon.ListEventReceiver`1"/></typeparam>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.RemoveEventReceiver``1">
            <summary>
            Removes list event receiver
            </summary>
            <typeparam name="TEventReceiver">Type inherited from <see cref="T:SharepointCommon.ListEventReceiver`1"/></typeparam>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.FormUrl(SharepointCommon.PageType,System.Int32,System.Boolean)">
            <summary>
            Gets the url of specific list form
            </summary>
            <param name="pageType">Type of the page.</param>
            <param name="id">The id of item</param>
            <param name="isDlg">Add 'isDlg=1' to form url</param>
            <returns>Url of list form with item id</returns>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.Add(`0)">
            <summary>
            Adds new list item to the list
            </summary>
            <param name="entity">instance of entity that represents new item</param>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.Update(`0,System.Boolean,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Updates specified field of existing item by data of entity
            </summary>
            <param name="entity">The entity instance.</param>
            <param name="incrementVersion">if set to <c>true</c>increments item version.</param>
            <param name="selectors">Expressions used to enumerate fields been updated. Ex: e => e.Title</param>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.UpdateField(`0,System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Object,System.Boolean)">
            <summary>
            
            </summary>
            <param name="entity"></param>
            <param name="fieldSelector"></param>
            <param name="valueToSet"></param>
            <param name="incrementVersion"></param>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.Delete(`0,System.Boolean)">
            <summary>
            Deletes the specified entity.
            </summary>
            <param name="entity">The entity.</param>
            <param name="recycle">if set to <c>true</c> to move in recycle bin.</param>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.Delete(System.Int32,System.Boolean)">
            <summary>
            Deletes item by the specified id.
            </summary>
            <param name="id">The id.</param>
            <param name="recycle">if set to <c>true</c> to move recycle bin.</param>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.ById(System.Int32)">
            <summary>
            Gets item by specified id.
            </summary>
            <param name="id">The item id.</param>
            <returns>List item instance.</returns>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.ById``1(System.Int32)">
            <summary>
            Gets item of specified content type by id
            </summary>
            <typeparam name="TCt">Type of entity, represents content type (marked with [ContentType])</typeparam>
            <param name="id">The item id.</param>
            <returns>List item instance.</returns>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.ByGuid(System.Guid)">
            <summary>
            Gets item by specified Guid (field 'GUID' not equals to 'UniqueId')
            </summary>
            <param name="id"></param>
            <returns>List item instance.</returns>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.ByGuid``1(System.Guid)">
            <summary>
            Gets item by specified content type Guid (field 'GUID' not equals to 'UniqueId')
            </summary>
            <typeparam name="TCt">Type of entity, represents content type (marked with [ContentType])</typeparam>
            <param name="id">the item id.</param>
            <returns>List item instance.</returns>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.ByField``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
            <summary>
            Gets items by value of specified field.
            </summary>
            <typeparam name="TR">type of value</typeparam>
            <param name="selector">Expression used to point needed field. Ex: e=>e.Title</param>
            <param name="value">value to filter items</param>
            <returns>items, which have specified value in specified field.</returns>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.Items(SharepointCommon.CamlQuery)">
            <summary>
            Gets items filtered by specified options
            </summary>
            <param name="option">The option used to filter items.</param>
            <returns>items by query</returns>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.Items``1(SharepointCommon.CamlQuery)">
            <summary>
            Gets items of specified content type, filtered by specified options.
            </summary>
            <typeparam name="TCt">Type of entity, represents content type (marked with [ContentType])</typeparam>
            <param name="option">The option used to filter items.</param>
            <returns>items by query.</returns>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.DeleteList(System.Boolean)">
            <summary>
            Deletes the list.
            </summary>
            <param name="recycle">if set to <c>true</c> to recycle list.</param>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.CheckFields">
            <summary>
            Check that all fields of '<typeparamref name="T"/>' are exists in list.
            If at least one of fields not exists, throw exception.
            </summary>
            <exception cref="T:SharepointCommon.SharepointCommonException"></exception>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.EnsureFields">
            <summary>
            Check that all fields of '<typeparamref name="T"/>' are exists in list.
            If some of fields not exists in list, creates it.
            </summary>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.EnsureField(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Ensure field in list.(Skip if exists, Create if not exists)
            </summary>
            <param name="selector">Expression used to point needed field. Ex: e=>e.Title</param>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.ContainsField(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Determines whether the specified field contains in list.
            </summary>
            <param name="selector">Expression used to point needed field. Ex: e=>e.Title</param>
            <returns>
            <c>true</c> if the specified selector contains field; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.GetField(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Gets the wrapper for SPField.
            </summary>
            <param name="selector">Expression used to point needed field. Ex: e=>e.Title</param>
            <returns>field wrapper</returns>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.GetFields(System.Boolean)">
            <summary>
            Gets the wrapper collection for list fields.
            </summary>
            <param name="onlyCustom">if set to <c>true</c> only custom fields; otherwise all fields.</param>
            <returns></returns>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.AddContentType``1">
            <summary>
            Adds the specified content type to list.
            </summary>
            <typeparam name="TCt">Type of entity, represents content type (marked with [ContentType]).</typeparam>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.ContainsContentType``1">
            <summary>
            Determines whether list contains specified content type.
            </summary>
            <typeparam name="TCt">Type of entity, represents content type (marked with [ContentType])</typeparam>
            <returns>
            <c>true</c> if [contains content type]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:SharepointCommon.IQueryList`1.RemoveContentType``1">
            <summary>
            Removes the specified content type from list.
            </summary>
            <typeparam name="TCt">Type of entity, represents content type (marked with [ContentType])</typeparam>
        </member>
        <member name="M:SharepointCommon.ListBase`1.#ctor">
            <summary>
            do not use this constructor in code, it is only for create derived types
            </summary>
        </member>
        <member name="T:SharepointCommon.User">
            <summary>
            Presents value for a 'User or Group' listitem field
            Used for SharePoint groups only, for domain user or group returns 'Person' object,
            but entity mapping should use only 'User' type
            </summary>
        </member>
        <member name="M:SharepointCommon.User.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SharepointCommon.User"/> class.
            </summary>
            <param name="name">SharePoint group name</param>
        </member>
        <member name="M:SharepointCommon.User.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SharepointCommon.User"/> class.
            </summary>
        </member>
        <member name="P:SharepointCommon.User.Id">
            <summary>
            Gets the id.
            </summary>
        </member>
        <member name="P:SharepointCommon.User.Name">
            <summary>
            Gets or sets the name.
            </summary>
            <value>
            The name.
            </value>
        </member>
        <member name="T:SharepointCommon.IQueryWeb">
            <summary>
            Represents an abstract wrapper for SPWeb and SPSite objects
            </summary>
        </member>
        <member name="P:SharepointCommon.IQueryWeb.Site">
            <summary>
            Gets the associated SPSite instance.
            </summary>
        </member>
        <member name="P:SharepointCommon.IQueryWeb.Web">
            <summary>
            Gets the associated SPWeb instance.
            </summary>
        </member>
        <member name="M:SharepointCommon.IQueryWeb.Elevate">
            <summary>
            Open Site and Web with a 'system account'
            </summary>
            <returns></returns>
        </member>
        <member name="M:SharepointCommon.IQueryWeb.Unsafe">
            <summary>
            Set AllowUnsafeUpdates on a 'Web'
            </summary>
            <returns></returns>
        </member>
        <member name="M:SharepointCommon.IQueryWeb.GetByUrl``1(System.String)">
            <summary>
            Gets the SPList wrapper by URL.
            </summary>
            <typeparam name="T">Item or ContentType entity</typeparam>
            <param name="listUrl">The list URL.</param>
            <returns>SPList wrapper</returns>
        </member>
        <member name="M:SharepointCommon.IQueryWeb.GetByName``1(System.String)">
            <summary>
            Gets the SPList wrapper by NAME.
            </summary>
            <typeparam name="T">Item or ContentType entity</typeparam>
            <param name="listName">Name of the list.</param>
            <returns>SPList wrapper</returns>
        </member>
        <member name="M:SharepointCommon.IQueryWeb.GetById``1(System.Guid)">
            <summary>
            Gets the SPList wrapper by ID.
            </summary>
            <typeparam name="T">Item or ContentType entity</typeparam>
            <param name="id">The ID.</param>
            <returns>SPList wrapper</returns>
        </member>
        <member name="M:SharepointCommon.IQueryWeb.CurrentList``1">
            <summary>
            Gets the SPList wrapper for a SPContext.Current.List
            </summary>
            <typeparam name="T">Item or ContentType entity</typeparam>
            <returns>SPList wrapper</returns>
        </member>
        <member name="M:SharepointCommon.IQueryWeb.Create``1(System.String)">
            <summary>
            Creates new List or Library with specified Name
            </summary>
            <typeparam name="T">Item or ContentType entity</typeparam>
            <param name="listName">Name of the list.</param>
            <returns>SPList wrapper</returns>
        </member>
        <member name="M:SharepointCommon.IQueryWeb.ExistsByUrl(System.String)">
            <summary>
            Checks that list with specified URL exists
            </summary>
            <param name="listUrl">The list URL.</param>
            <returns>true if exists</returns>
        </member>
        <member name="M:SharepointCommon.IQueryWeb.ExistsByName(System.String)">
            <summary>
            Checks that list with specified NAME exists
            </summary>
            <param name="listName">Name of the list.</param>
            <returns>true if exists</returns>
        </member>
        <member name="M:SharepointCommon.IQueryWeb.ExistsById(System.Guid)">
            <summary>
            Checks that list with specified ID exists
            </summary>
            <param name="id">The list id.</param>
            <returns>true if exists</returns>
        </member>
        <member name="T:SharepointCommon.WebFactory">
            <summary>
            Presents framework entry point. Allows to get instance of IQueryWeb
            </summary>
        </member>
        <member name="M:SharepointCommon.WebFactory.Open(System.String)">
            <summary>
            Opens wrapper for SPWeb and SPSite by URL
            </summary>
            <param name="url">The URL.</param>
            <returns>abstract wrapper for SPWeb and SPSite objects</returns>
        </member>
        <member name="M:SharepointCommon.WebFactory.Open(Microsoft.SharePoint.SPWeb)">
            <summary>
            Create wrapper based on existing SPWeb object
            </summary>
            <param name="spWeb">SPWeb object.Will not disposed internally!</param>
            <returns>abstract wrapper for SPWeb and SPSite objects</returns>
        </member>
        <member name="M:SharepointCommon.WebFactory.Open(System.Guid)">
            <summary>
            Opens wrapper for SPWeb and SPSite by SPSite ID
            </summary>
            <param name="site">SPSite ID</param>
            <returns>abstract wrapper for SPWeb and SPSite objects</returns>
        </member>
        <member name="M:SharepointCommon.WebFactory.Open(System.Guid,System.Guid)">
            <summary>
            Opens wrapper for SPWeb and SPSite by their ID's
            </summary>
            <param name="site">SPSite id</param>
            <param name="web">SPWeb id</param>
            <returns>abstract wrapper for SPWeb and SPSite objects</returns>
        </member>
        <member name="M:SharepointCommon.WebFactory.Open(System.Guid,System.Guid,Microsoft.SharePoint.Administration.SPUrlZone)">
            <summary>
            Opens wrapper for SPWeb and SPSite by their ID's
            </summary>
            <param name="site">SPSite id</param>
            <param name="web">SPWeb id</param>
            <param name="zone">site zone</param>
            <returns>abstract wrapper for SPWeb and SPSite objects</returns>
        </member>
        <member name="M:SharepointCommon.WebFactory.Elevated(System.String)">
            <summary>
            Opens wrapper for SPWeb and SPSite by URL in elevated mode
            </summary>
            <param name="url">Web URL</param>
            <returns>abstract wrapper for SPWeb and SPSite objects</returns>
        </member>
        <member name="M:SharepointCommon.WebFactory.Elevated(System.Guid)">
            <summary>
            Opens wrapper for SPWeb and SPSite by site.id in elevated mode
            </summary>
            <param name="site">site id</param>
            <returns>abstract wrapper for SPWeb and SPSite objects</returns>
        </member>
        <member name="M:SharepointCommon.WebFactory.Elevated(System.Guid,System.Guid)">
            <summary>
            Opens wrapper for SPWeb and SPSite by their ID's in elevated mode
            </summary>
            <param name="site">site id</param>
            <param name="web">web id</param>
            <returns>abstract wrapper for SPWeb and SPSite objects</returns>
        </member>
        <member name="M:SharepointCommon.WebFactory.Unsafe(System.String)">
            <summary>
            Opens wrapper for SPWeb and SPSite by URL and sets AllowUnsafeUpdates for SPWeb
            </summary>
            <param name="url">web URL</param>
            <returns>abstract wrapper for SPWeb and SPSite objects</returns>
        </member>
        <member name="M:SharepointCommon.WebFactory.Unsafe(System.Guid,System.Guid)">
            <summary>
            Opens wrapper for SPWeb and SPSite by their ID's and sets AllowUnsafeUpdates for SPWeb
            </summary>
            <param name="site">site id</param>
            <param name="web">web id</param>
            <returns>abstract wrapper for SPWeb and SPSite objects</returns>
        </member>
        <member name="M:SharepointCommon.WebFactory.CurrentContext">
            <summary>
            Opens wrapper for SPWeb and SPSite by SPContext.Current.Web.Url
            </summary>
            <returns>abstract wrapper for SPWeb and SPSite objects</returns>
        </member>
        <member name="T:Castle.Core.Internal.AttributesUtil">
            <summary>
              Helper class for retrieving attributes.
            </summary>
        </member>
        <member name="M:Castle.Core.Internal.AttributesUtil.GetAttribute``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
              Gets the attribute.
            </summary>
            <param name = "member">The member.</param>
            <returns>The member attribute.</returns>
        </member>
        <member name="M:Castle.Core.Internal.AttributesUtil.GetAttributes``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
              Gets the attributes. Does not consider inherited attributes!
            </summary>
            <param name = "member">The member.</param>
            <returns>The member attributes.</returns>
        </member>
        <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeAttribute``1(System.Type)">
            <summary>
              Gets the type attribute.
            </summary>
            <param name = "type">The type.</param>
            <returns>The type attribute.</returns>
        </member>
        <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeAttributes``1(System.Type)">
            <summary>
              Gets the type attributes.
            </summary>
            <param name = "type">The type.</param>
            <returns>The type attributes.</returns>
        </member>
        <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeConverter(System.Reflection.MemberInfo)">
            <summary>
              Gets the type converter.
            </summary>
            <param name = "member">The member.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Internal.AttributesUtil.HasAttribute``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
              Gets the attribute.
            </summary>
            <param name = "member">The member.</param>
            <returns>The member attribute.</returns>
        </member>
        <member name="M:Castle.Core.Internal.CollectionExtensions.IsNullOrEmpty(System.Collections.IEnumerable)">
            <summary>
              Checks whether or not collection is null or empty. Assumes colleciton can be safely enumerated multiple times.
            </summary>
            <param name = "this"></param>
            <returns></returns>
        </member>
        <member name="F:Castle.Core.Internal.InternalsVisible.ToCastleCore">
            <summary>
              Constant to use when making assembly internals visible to Castle.Core 
              <c>[assembly: InternalsVisibleTo(CoreInternalsVisible.ToCastleCore)]</c>
            </summary>
        </member>
        <member name="F:Castle.Core.Internal.InternalsVisible.ToDynamicProxyGenAssembly2">
            <summary>
              Constant to use when making assembly internals visible to proxy types generated by DynamicProxy. Required when proxying internal types.
              <c>[assembly: InternalsVisibleTo(CoreInternalsVisible.ToDynamicProxyGenAssembly2)]</c>
            </summary>
        </member>
        <member name="M:Castle.Core.Internal.Lock.Create">
            <summary>
            Creates a new lock.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.Type)">
            <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.String)">
            <summary>
              Creates a new extended logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates a new extended logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Castle#Core#Logging#ILoggerFactory#Create(System.Type)">
            <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Castle#Core#Logging#ILoggerFactory#Create(System.String)">
            <summary>
              Creates a new logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Castle#Core#Logging#ILoggerFactory#Create(System.Type,Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Castle#Core#Logging#ILoggerFactory#Create(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates a new logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.GetConfigFile(System.String)">
            <summary>
              Gets the configuration file.
            </summary>
            <param name = "fileName">i.e. log4net.config</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Logging.AbstractLoggerFactory.GetConfigFile(System.String)">
            <summary>
              Gets the configuration file.
            </summary>
            <param name = "fileName">i.e. log4net.config</param>
            <returns></returns>
        </member>
        <member name="T:Castle.Core.Logging.ConsoleLogger">
            <summary>
            The Logger sending everything to the standard output streams.
            This is mainly for the cases when you have a utility that
            does not have a logger to supply.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor">
            <summary>
              Creates a new ConsoleLogger with the <c>Level</c>
              set to <c>LoggerLevel.Debug</c> and the <c>Name</c>
              set to <c>String.Empty</c>.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates a new ConsoleLogger with the <c>Name</c>
              set to <c>String.Empty</c>.
            </summary>
            <param name = "logLevel">The logs Level.</param>
        </member>
        <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String)">
            <summary>
              Creates a new ConsoleLogger with the <c>Level</c>
              set to <c>LoggerLevel.Debug</c>.
            </summary>
            <param name = "name">The logs Name.</param>
        </member>
        <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates a new ConsoleLogger.
            </summary>
            <param name = "name">The logs Name.</param>
            <param name = "logLevel">The logs Level.</param>
        </member>
        <member name="M:Castle.Core.Logging.ConsoleLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
            <summary>
              A Common method to log.
            </summary>
            <param name = "loggerLevel">The level of logging</param>
            <param name = "loggerName">The name of the logger</param>
            <param name = "message">The Message</param>
            <param name = "exception">The Exception</param>
        </member>
        <member name="M:Castle.Core.Logging.ConsoleLogger.CreateChildLogger(System.String)">
            <summary>
              Returns a new <c>ConsoleLogger</c> with the name
              added after this loggers name, with a dot in between.
            </summary>
            <param name = "loggerName">The added hierarchical name.</param>
            <returns>A new <c>ConsoleLogger</c>.</returns>
        </member>
        <member name="T:Castle.Core.Logging.DiagnosticsLogger">
            <summary>
              The Logger using standart Diagnostics namespace.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String)">
            <summary>
              Creates a logger based on <see cref = "T:System.Diagnostics.EventLog" />.
            </summary>
            <param name = "logName"><see cref = "P:System.Diagnostics.EventLog.Log" /></param>
        </member>
        <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String)">
            <summary>
              Creates a logger based on <see cref = "T:System.Diagnostics.EventLog" />.
            </summary>
            <param name = "logName"><see cref = "P:System.Diagnostics.EventLog.Log" /></param>
            <param name = "source"><see cref = "P:System.Diagnostics.EventLog.Source" /></param>
        </member>
        <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String,System.String)">
            <summary>
              Creates a logger based on <see cref = "T:System.Diagnostics.EventLog" />.
            </summary>
            <param name = "logName"><see cref = "P:System.Diagnostics.EventLog.Log" /></param>
            <param name = "machineName"><see cref = "P:System.Diagnostics.EventLog.MachineName" /></param>
            <param name = "source"><see cref = "P:System.Diagnostics.EventLog.Source" /></param>
        </member>
        <member name="T:Castle.Core.Logging.IContextProperties">
            <summary>
              Interface for Context Properties implementations
            </summary>
            <remarks>
              <para>
                This interface defines a basic property get set accessor.
              </para>
              <para>
                Based on the ContextPropertiesBase of log4net, by Nicko Cadell.
              </para>
            </remarks>
        </member>
        <member name="P:Castle.Core.Logging.IContextProperties.Item(System.String)">
            <summary>
              Gets or sets the value of a property
            </summary>
            <value>
              The value for the property with the specified key
            </value>
            <remarks>
              <para>
                Gets or sets the value of a property
              </para>
            </remarks>
        </member>
        <member name="T:Castle.Core.Logging.IExtendedLogger">
            <summary>
              Provides an interface that supports <see cref = "T:Castle.Core.Logging.ILogger" /> and
              allows the storage and retrieval of Contexts. These are supported in
              both log4net and NLog.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.IExtendedLogger.GlobalProperties">
            <summary>
              Exposes the Global Context of the extended logger.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadProperties">
            <summary>
              Exposes the Thread Context of the extended logger.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadStacks">
            <summary>
              Exposes the Thread Stack of the extended logger.
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.IExtendedLoggerFactory">
            <summary>
              Provides a factory that can produce either <see cref = "T:Castle.Core.Logging.ILogger" /> or
              <see cref = "T:Castle.Core.Logging.IExtendedLogger" /> classes.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type)">
            <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String)">
            <summary>
              Creates a new extended logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates a new extended logger.
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.ILogger">
            <summary>
              Manages logging.
            </summary>
            <remarks>
              This is a facade for the different logging subsystems.
              It offers a simplified interface that follows IOC patterns
              and a simplified priority/level/severity abstraction.
            </remarks>
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsDebugEnabled">
            <summary>
              Determines if messages of priority "debug" will be logged.
            </summary>
            <value>True if "debug" messages will be logged.</value>
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsErrorEnabled">
            <summary>
              Determines if messages of priority "error" will be logged.
            </summary>
            <value>True if "error" messages will be logged.</value>
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsFatalEnabled">
            <summary>
              Determines if messages of priority "fatal" will be logged.
            </summary>
            <value>True if "fatal" messages will be logged.</value>
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsInfoEnabled">
            <summary>
              Determines if messages of priority "info" will be logged.
            </summary>
            <value>True if "info" messages will be logged.</value>
        </member>
        <member name="P:Castle.Core.Logging.ILogger.IsWarnEnabled">
            <summary>
              Determines if messages of priority "warn" will be logged.
            </summary>
            <value>True if "warn" messages will be logged.</value>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.CreateChildLogger(System.String)">
            <summary>
              Create a new child logger.
              The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
            <param name = "loggerName">The Subname of this logger.</param>
            <returns>The New ILogger instance.</returns>
            <exception cref = "T:System.ArgumentException">If the name has an empty element name.</exception>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Debug(System.String)">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Debug(System.Func{System.String})">
            <summary>
              Logs a debug message with lazily constructed message. The message will be constructed only if the <see cref = "P:Castle.Core.Logging.ILogger.IsDebugEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Exception)">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Error(System.String)">
            <summary>
              Logs an error message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Error(System.Func{System.String})">
            <summary>
              Logs an error message with lazily constructed message. The message will be constructed only if the <see cref = "P:Castle.Core.Logging.ILogger.IsErrorEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Exception)">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String)">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Fatal(System.Func{System.String})">
            <summary>
              Logs a fatal message with lazily constructed message. The message will be constructed only if the <see cref = "P:Castle.Core.Logging.ILogger.IsFatalEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Exception)">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Info(System.String)">
            <summary>
              Logs an info message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Info(System.Func{System.String})">
            <summary>
              Logs a info message with lazily constructed message. The message will be constructed only if the <see cref = "P:Castle.Core.Logging.ILogger.IsInfoEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Exception)">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Warn(System.String)">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Warn(System.Func{System.String})">
            <summary>
              Logs a warn message with lazily constructed message. The message will be constructed only if the <see cref = "P:Castle.Core.Logging.ILogger.IsWarnEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Exception)">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="T:Castle.Core.Logging.ILoggerFactory">
            <summary>
              Manages the instantiation of <see cref = "T:Castle.Core.Logging.ILogger" />s.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type)">
            <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String)">
            <summary>
              Creates a new logger.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates a new logger.
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.LevelFilteredLogger">
            <summary>
            The Level Filtered Logger class.  This is a base clase which
            provides a LogLevel attribute and reroutes all functions into
            one Log method.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.#ctor">
            <summary>
              Creates a new <c>LevelFilteredLogger</c>.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.InitializeLifetimeService">
            <summary>
            Keep the instance alive in a remoting scenario
            </summary>
            <returns></returns>
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.Level">
            <value>
              The <c>LoggerLevel</c> that this logger
              will be using. Defaults to <c>LoggerLevel.Off</c>
            </value>
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.Name">
            <value>
              The name that this logger will be using. 
              Defaults to <c>String.Empty</c>
            </value>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String)">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String,System.Exception)">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String)">
            <summary>
              Logs an info message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String,System.Exception)">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String)">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String,System.Exception)">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String)">
            <summary>
              Logs an error message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String,System.Exception)">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String)">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String,System.Exception)">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsDebugEnabled">
            <summary>
              Determines if messages of priority "debug" will be logged.
            </summary>
            <value><c>true</c> if log level flags include the <see cref = "F:Castle.Core.Logging.LoggerLevel.Debug" /> bit</value>
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsInfoEnabled">
            <summary>
              Determines if messages of priority "info" will be logged.
            </summary>
            <value><c>true</c> if log level flags include the <see cref = "F:Castle.Core.Logging.LoggerLevel.Info" /> bit</value>
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsWarnEnabled">
            <summary>
              Determines if messages of priority "warn" will be logged.
            </summary>
            <value><c>true</c> if log level flags include the <see cref = "F:Castle.Core.Logging.LoggerLevel.Warn" /> bit</value>
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsErrorEnabled">
            <summary>
              Determines if messages of priority "error" will be logged.
            </summary>
            <value><c>true</c> if log level flags include the <see cref = "F:Castle.Core.Logging.LoggerLevel.Error" /> bit</value>
        </member>
        <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsFatalEnabled">
            <summary>
              Determines if messages of priority "fatal" will be logged.
            </summary>
            <value><c>true</c> if log level flags include the <see cref = "F:Castle.Core.Logging.LoggerLevel.Fatal" /> bit</value>
        </member>
        <member name="M:Castle.Core.Logging.LevelFilteredLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
            <summary>
              Implementors output the log content by implementing this method only.
              Note that exception can be null
            </summary>
            <param name = "loggerLevel"></param>
            <param name = "loggerName"></param>
            <param name = "message"></param>
            <param name = "exception"></param>
        </member>
        <member name="T:Castle.Core.Logging.LoggerLevel">
            <summary>
              Supporting Logger levels.
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Off">
            <summary>
              Logging will be off
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Fatal">
            <summary>
              Fatal logging level
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Error">
            <summary>
              Error logging level
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Warn">
            <summary>
              Warn logging level
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Info">
            <summary>
              Info logging level
            </summary>
        </member>
        <member name="F:Castle.Core.Logging.LoggerLevel.Debug">
            <summary>
              Debug logging level
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.NullLogFactory">
            <summary>
            NullLogFactory used when logging is turned off.
            </summary>
        </member>
        <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String)">
            <summary>
              Creates an instance of ILogger with the specified name.
            </summary>
            <param name = "name">Name.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
              Creates an instance of ILogger with the specified name and LoggerLevel.
            </summary>
            <param name = "name">Name.</param>
            <param name = "level">Level.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.Core.Logging.NullLogger">
            <summary>
              The Null Logger class.  This is useful for implementations where you need
              to provide a logger to a utility class, but do not want any output from it.
              It also helps when you have a utility that does not have a logger to supply.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.GlobalProperties">
            <summary>
              Returns empty context properties.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.ThreadProperties">
            <summary>
              Returns empty context properties.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.ThreadStacks">
            <summary>
              Returns empty context stacks.
            </summary>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsDebugEnabled">
            <summary>
              No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsErrorEnabled">
            <summary>
              No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsFatalEnabled">
            <summary>
              No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsInfoEnabled">
            <summary>
              No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="P:Castle.Core.Logging.NullLogger.IsWarnEnabled">
            <summary>
              No-op.
            </summary>
            <value>false</value>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.CreateChildLogger(System.String)">
            <summary>
              Returns this <c>NullLogger</c>.
            </summary>
            <param name = "loggerName">Ignored</param>
            <returns>This ILogger instance.</returns>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String)">
            <summary>
              No-op.
            </summary>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Exception)">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Error(System.String)">
            <summary>
              No-op.
            </summary>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Exception)">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String)">
            <summary>
              No-op.
            </summary>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Exception)">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Info(System.String)">
            <summary>
              No-op.
            </summary>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Exception)">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String)">
            <summary>
              No-op.
            </summary>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Exception)">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "message">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              No-op.
            </summary>
            <param name = "exception">Ignored</param>
            <param name = "formatProvider">Ignored</param>
            <param name = "format">Ignored</param>
            <param name = "args">Ignored</param>
        </member>
        <member name="T:Castle.Core.Logging.StreamLogger">
            <summary>
            The Stream Logger class.  This class can stream log information
            to any stream, it is suitable for storing a log file to disk,
            or to a <c>MemoryStream</c> for testing your components.
            </summary>
            <remarks>
            This logger is not thread safe.
            </remarks>
        </member>
        <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream)">
            <summary>
              Creates a new <c>StreamLogger</c> with default encoding 
              and buffer size. Initial Level is set to Debug.
            </summary>
            <param name = "name">
              The name of the log.
            </param>
            <param name = "stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
        </member>
        <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding)">
            <summary>
              Creates a new <c>StreamLogger</c> with default buffer size.
              Initial Level is set to Debug.
            </summary>
            <param name = "name">
              The name of the log.
            </param>
            <param name = "stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
            <param name = "encoding">
              The encoding that will be used for this stream.
              <see cref = "T:System.IO.StreamWriter" />
            </param>
        </member>
        <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding,System.Int32)">
            <summary>
              Creates a new <c>StreamLogger</c>. 
              Initial Level is set to Debug.
            </summary>
            <param name = "name">
              The name of the log.
            </param>
            <param name = "stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
            <param name = "encoding">
              The encoding that will be used for this stream.
              <see cref = "T:System.IO.StreamWriter" />
            </param>
            <param name = "bufferSize">
              The buffer size that will be used for this stream.
              <see cref = "T:System.IO.StreamWriter" />
            </param>
        </member>
        <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.StreamWriter)">
            <summary>
              Creates a new <c>StreamLogger</c> with 
              Debug as default Level.
            </summary>
            <param name = "name">The name of the log.</param>
            <param name = "writer">The <c>StreamWriter</c> the log will write to.</param>
        </member>
        <member name="T:Castle.Core.Logging.StreamLoggerFactory">
            <summary>
              Creates <see cref = "T:Castle.Core.Logging.StreamLogger" /> outputing 
              to files. The name of the file is derived from the log name
              plus the 'log' extension.
            </summary>
        </member>
        <member name="T:Castle.Core.Logging.TraceLogger">
            <summary>
              The TraceLogger sends all logging to the System.Diagnostics.TraceSource
              built into the .net framework.
            </summary>
            <remarks>
              Logging can be configured in the system.diagnostics configuration 
              section. 
            
              If logger doesn't find a source name with a full match it will
              use source names which match the namespace partially. For example you can
              configure from all castle components by adding a source name with the
              name "Castle". 
            
              If no portion of the namespace matches the source named "Default" will
              be used.
            </remarks>
        </member>
        <member name="M:Castle.Core.Logging.TraceLogger.#ctor(System.String)">
            <summary>
            Build a new trace logger based on the named TraceSource
            </summary>
            <param name="name">The name used to locate the best TraceSource. In most cases comes from the using type's fullname.</param>
        </member>
        <member name="M:Castle.Core.Logging.TraceLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
            <summary>
            Build a new trace logger based on the named TraceSource
            </summary>
            <param name="name">The name used to locate the best TraceSource. In most cases comes from the using type's fullname.</param>
            <param name="level">The default logging level at which this source should write messages. In almost all cases this
            default value will be overridden in the config file. </param>
        </member>
        <member name="M:Castle.Core.Logging.TraceLogger.CreateChildLogger(System.String)">
            <summary>
            Create a new child logger.
            The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
            <param name="loggerName">The Subname of this logger.</param>
            <returns>The New ILogger instance.</returns> 
        </member>
        <member name="T:Castle.Core.Logging.TraceLoggerFactory">
            <summary>
              Used to create the TraceLogger implementation of ILogger interface. See <see cref = "T:Castle.Core.Logging.TraceLogger" />.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Contributors.ITypeContributor">
            <summary>
              Interface describing elements composing generated type
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Contributors.MembersCollector.AcceptMethod(System.Reflection.MethodInfo,System.Boolean,Castle.DynamicProxy.IProxyGenerationHook)">
            <summary>
              Performs some basic screening and invokes the <see cref = "T:Castle.DynamicProxy.IProxyGenerationHook" />
              to select methods.
            </summary>
            <param name = "method"></param>
            <param name = "onlyVirtuals"></param>
            <param name = "hook"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.DynamicProxy.DefaultProxyBuilder">
            <summary>
              Default implementation of <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> interface producing in-memory proxy assemblies.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.DefaultProxyBuilder" /> class with new <see cref = "P:Castle.DynamicProxy.DefaultProxyBuilder.ModuleScope" />.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor(Castle.DynamicProxy.ModuleScope)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.DefaultProxyBuilder" /> class.
            </summary>
            <param name = "scope">The module scope for generated proxy types.</param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.HandleError(System.Type,System.Exception)">
            <summary>
              Handles error during disassembly process
            </summary>
            <param name = "attributeType">Type of the attribute being disassembled</param>
            <param name = "exception">Exception thrown during the process</param>
            <returns>usually null, or (re)throws the exception</returns>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.InitializeConstructorArgs(System.Type,System.Attribute,System.Reflection.ParameterInfo[])">
            <summary>
              Here we try to match a constructor argument to its value.
              Since we can't get the values from the assembly, we use some heuristics to get it.
              a/ we first try to match all the properties on the attributes by name (case insensitive) to the argument
              b/ if we fail we try to match them by property type, with some smarts about convertions (i,e: can use Guid for string).
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ReplaceIfBetterMatch(System.Reflection.ParameterInfo,System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)">
            <summary>
              We have the following rules here.
              Try to find a matching type, failing that, if the parameter is string, get the first property (under the assumption that
              we can convert it.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ConvertValue(System.Object,System.Type)">
            <summary>
              Attributes can only accept simple types, so we return null for null,
              if the value is passed as string we call to string (should help with converting), 
              otherwise, we use the value as is (enums, integer, etc).
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.BaseProxyGenerator">
            <summary>
              Base class that exposes the common functionalities
              to proxy generation.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.AddMappingNoCheck(System.Type,Castle.DynamicProxy.Contributors.ITypeContributor,System.Collections.Generic.IDictionary{System.Type,Castle.DynamicProxy.Contributors.ITypeContributor})">
            <summary>
              It is safe to add mapping (no mapping for the interface exists)
            </summary>
            <param name = "implementer"></param>
            <param name = "interface"></param>
            <param name = "mapping"></param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.GenerateParameterlessConstructor(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference)">
            <summary>
              Generates a parameters constructor that initializes the proxy
              state with <see cref = "T:Castle.DynamicProxy.StandardInterceptor" /> just to make it non-null.
              <para>
                This constructor is important to allow proxies to be XML serializable
              </para>
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Reflection.MemberInfo,System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
            <param name = "target">Target element. This is either target type or target method for invocation types.</param>
            <param name = "type">The type of the proxy. This is base type for invocation types.</param>
            <param name = "interfaces">The interfaces.</param>
            <param name = "options">The options.</param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
            <param name = "target">Type of the target.</param>
            <param name = "interfaces">The interfaces.</param>
            <param name = "options">The options.</param>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.LdcOpCodesDictionary">
            <summary>
              s
              Provides appropriate Ldc.X opcode for the type of primitive value to be loaded.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.LdindOpCodesDictionary">
            <summary>
              Provides appropriate Ldind.X opcode for 
              the type of primitive value to be loaded indirectly.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
              Emits a load indirect opcode of the appropriate type for a value or object reference.
              Pops a pointer off the evaluation stack, dereferences it and loads
              a value of the specified type.
            </summary>
            <param name = "gen"></param>
            <param name = "type"></param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForConstantValue(System.Reflection.Emit.ILGenerator,System.Object)">
            <summary>
              Emits a load opcode of the appropriate kind for a constant string or
              primitive value.
            </summary>
            <param name = "gen"></param>
            <param name = "value"></param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForDefaultValueOfType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
              Emits a load opcode of the appropriate kind for the constant default value of a
              type, such as 0 for value types and null for reference types.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitStoreIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
              Emits a store indirectopcode of the appropriate type for a value or object reference.
              Pops a value of the specified type and a pointer off the evaluation stack, and
              stores the value.
            </summary>
            <param name = "gen"></param>
            <param name = "type"></param>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.PropertiesCollection">
            <summary>
              Summary description for PropertiesCollection.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.IndirectReference">
            <summary>
              Wraps a reference that is passed 
              ByRef and provides indirect load/store support.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewArrayExpression">
            <summary>
              Summary description for NewArrayExpression.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferencesToObjectArrayExpression">
            <summary>
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.Emitters.StindOpCodesDictionary">
            <summary>
              Provides appropriate Stind.X opcode 
              for the type of primitive value to be stored indirectly.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.Emitters.TypeUtil.GetAllInterfaces(System.Type[])">
            <summary>
              Returns list of all unique interfaces implemented given types, including their base interfaces.
            </summary>
            <param name = "types"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.INamingScope">
            <summary>
              Represents the scope of uniquenes of names for types and their members
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)">
            <summary>
              Gets a unique name based on <paramref name = "suggestedName" />
            </summary>
            <param name = "suggestedName">Name suggested by the caller</param>
            <returns>Unique name based on <paramref name = "suggestedName" />.</returns>
            <remarks>
              Implementers should provide name as closely resembling <paramref name = "suggestedName" /> as possible.
              Generally if no collision occurs it is suggested to return suggested name, otherwise append sequential suffix.
              Implementers must return deterministic names, that is when <see cref = "M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)" /> is called twice 
              with the same suggested name, the same returned name should be provided each time. Non-deterministic return
              values, like appending random suffices will break serialization of proxies.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.INamingScope.SafeSubScope">
            <summary>
              Returns new, disposable naming scope. It is responsibilty of the caller to make sure that no naming collision
              with enclosing scope, or other subscopes is possible.
            </summary>
            <returns>New naming scope.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.InvocationTypeGenerator.GetBaseCtorArguments(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Reflection.ConstructorInfo@)">
            <summary>
              Generates the constructor for the class that extends
              <see cref = "T:Castle.DynamicProxy.AbstractInvocation" />
            </summary>
            <param name = "targetFieldType"></param>
            <param name = "proxyGenerationOptions"></param>
            <param name = "baseConstructor"></param>
        </member>
        <member name="M:Castle.DynamicProxy.Generators.MetaEvent.#ctor(System.String,System.Type,System.Type,Castle.DynamicProxy.Generators.MetaMethod,Castle.DynamicProxy.Generators.MetaMethod,System.Reflection.EventAttributes)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.Generators.MetaEvent" /> class.
            </summary>
            <param name = "name">The name.</param>
            <param name = "declaringType">Type declaring the original event being overriten, or null.</param>
            <param name = "eventDelegateType"></param>
            <param name = "adder">The add method.</param>
            <param name = "remover">The remove method.</param>
            <param name = "attributes">The attributes.</param>
        </member>
        <member name="T:Castle.DynamicProxy.Generators.MethodFinder">
            <summary>
              Returns the methods implemented by a type. Use this instead of Type.GetMethods() to work around a CLR issue
              where duplicate MethodInfos are returned by Type.GetMethods() after a token of a generic type's method was loaded.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.IAttributeDisassembler">
            <summary>
              Provides functionality for disassembling instances of attributes to CustomAttributeBuilder form, during the process of emiting new types by Dynamic Proxy.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.IAttributeDisassembler.Disassemble(System.Attribute)">
            <summary>
              Disassembles given attribute instance back to corresponding CustomAttributeBuilder.
            </summary>
            <param name = "attribute">An instance of attribute to disassemble</param>
            <returns><see cref = "T:System.Reflection.Emit.CustomAttributeBuilder" /> corresponding 1 to 1 to given attribute instance, or null reference.</returns>
            <remarks>
              Implementers should return <see cref = "T:System.Reflection.Emit.CustomAttributeBuilder" /> that corresponds to given attribute instance 1 to 1,
              that is after calling specified constructor with specified arguments, and setting specified properties and fields with values specified
              we should be able to get an attribute instance identical to the one passed in <paramref name = "attribute" />. Implementer can return null
              if it wishes to opt out of replicating the attribute. Notice however, that for some cases, like attributes passed explicitly by the user
              it is illegal to return null, and doing so will result in exception.
            </remarks>
        </member>
        <member name="T:Castle.DynamicProxy.IChangeProxyTarget">
            <summary>
              Exposes means to change target objects of proxies and invocations
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.IChangeProxyTarget.ChangeInvocationTarget(System.Object)">
            <summary>
              Changes the target object (<see cref = "P:Castle.DynamicProxy.IInvocation.InvocationTarget" />) of current <see cref = "T:Castle.DynamicProxy.IInvocation" />.
            </summary>
            <param name = "target">The new value of target of invocation.</param>
            <remarks>
              Although the method takes <see cref = "T:System.Object" /> the actual instance must be of type assignable to <see
               cref = "P:Castle.DynamicProxy.IInvocation.TargetType" />, otherwise an <see cref = "T:System.InvalidCastException" /> will be thrown.
              Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name = "target" />, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
              In this case last interceptor in the pipeline mustn't call <see cref = "M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see
               cref = "T:System.NotImplementedException" /> will be throws.
              Also while it's technically legal to pass proxy itself as <paramref name = "target" />, this would create stack overflow.
              In this case last interceptor in the pipeline mustn't call <see cref = "M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see
               cref = "T:System.InvalidOperationException" /> will be throws.
            </remarks>
            <exception cref = "T:System.InvalidCastException">Thrown when <paramref name = "target" /> is not assignable to the proxied type.</exception>
        </member>
        <member name="M:Castle.DynamicProxy.IChangeProxyTarget.ChangeProxyTarget(System.Object)">
            <summary>
              Permanently changes the target object of the proxy. This does not affect target of the current invocation.
            </summary>
            <param name = "target">The new value of target of the proxy.</param>
            <remarks>
              Although the method takes <see cref = "T:System.Object" /> the actual instance must be of type assignable to proxy's target type, otherwise an <see
               cref = "T:System.InvalidCastException" /> will be thrown.
              Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name = "target" />, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
              In this case last interceptor in the pipeline mustn't call <see cref = "M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see
               cref = "T:System.NotImplementedException" /> will be throws.
              Also while it's technically legal to pass proxy itself as <paramref name = "target" />, this would create stack overflow.
              In this case last interceptor in the pipeline mustn't call <see cref = "M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see
               cref = "T:System.InvalidOperationException" /> will be throws.
            </remarks>
            <exception cref = "T:System.InvalidCastException">Thrown when <paramref name = "target" /> is not assignable to the proxied type.</exception>
        </member>
        <member name="T:Castle.DynamicProxy.IInterceptor">
            <summary>
              New interface that is going to be used by DynamicProxy 2
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.IInterceptorSelector">
            <summary>
              Provides an extension point that allows proxies to choose specific interceptors on
              a per method basis.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.IInterceptorSelector.SelectInterceptors(System.Type,System.Reflection.MethodInfo,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Selects the interceptors that should intercept calls to the given <paramref name = "method" />.
            </summary>
            <param name = "type">The type declaring the method to intercept.</param>
            <param name = "method">The method that will be intercepted.</param>
            <param name = "interceptors">All interceptors registered with the proxy.</param>
            <returns>An array of interceptors to invoke upon calling the <paramref name = "method" />.</returns>
            <remarks>
              This method is called only once per proxy instance, upon the first call to the
              <paramref name = "method" />. Either an empty array or null are valid return values to indicate
              that no interceptor should intercept calls to the method. Although it is not advised, it is
              legal to return other <see cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations than these provided in
              <paramref name = "interceptors" />.
            </remarks>
        </member>
        <member name="T:Castle.DynamicProxy.IInvocation">
            <summary>
              Encapsulates an invocation of a proxied method.
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.Arguments">
            <summary>
              Gets the arguments that the <see cref = "P:Castle.DynamicProxy.IInvocation.Method" /> has been invoked with.
            </summary>
            <value>The arguments the method was invoked with.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.GenericArguments">
            <summary>
              Gets the generic arguments of the method.
            </summary>
            <value>The generic arguments, or null if not a generic method.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.InvocationTarget">
            <summary>
              Gets the object on which the invocation is performed. This is different from proxy object
              because most of the time this will be the proxy target object.
            </summary>
            <seealso cref = "T:Castle.DynamicProxy.IChangeProxyTarget" />
            <value>The invocation target.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.Method">
            <summary>
              Gets the <see cref = "T:System.Reflection.MethodInfo" /> representing the method being invoked on the proxy.
            </summary>
            <value>The <see cref = "T:System.Reflection.MethodInfo" /> representing the method being invoked.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget">
            <summary>
              For interface proxies, this will point to the <see cref = "T:System.Reflection.MethodInfo" /> on the target class.
            </summary>
            <value>The method invocation target.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.Proxy">
            <summary>
              Gets the proxy object on which the intercepted method is invoked.
            </summary>
            <value>Proxy object on which the intercepted method is invoked.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.ReturnValue">
            <summary>
              Gets or sets the return value of the method.
            </summary>
            <value>The return value of the method.</value>
        </member>
        <member name="P:Castle.DynamicProxy.IInvocation.TargetType">
            <summary>
              Gets the type of the target object for the intercepted method.
            </summary>
            <value>The type of the target object.</value>
        </member>
        <member name="M:Castle.DynamicProxy.IInvocation.GetArgumentValue(System.Int32)">
            <summary>
              Gets the value of the argument at the specified <paramref name = "index" />.
            </summary>
            <param name = "index">The index.</param>
            <returns>The value of the argument at the specified <paramref name = "index" />.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.IInvocation.GetConcreteMethod">
            <summary>
              Returns the concrete instantiation of the <see cref = "P:Castle.DynamicProxy.IInvocation.Method" /> on the proxy, with any generic
              parameters bound to real types.
            </summary>
            <returns>
              The concrete instantiation of the <see cref = "P:Castle.DynamicProxy.IInvocation.Method" /> on the proxy, or the <see cref = "P:Castle.DynamicProxy.IInvocation.Method" /> if
              not a generic method.
            </returns>
            <remarks>
              Can be slower than calling <see cref = "P:Castle.DynamicProxy.IInvocation.Method" />.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.IInvocation.GetConcreteMethodInvocationTarget">
            <summary>
              Returns the concrete instantiation of <see cref = "P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />, with any
              generic parameters bound to real types.
              For interface proxies, this will point to the <see cref = "T:System.Reflection.MethodInfo" /> on the target class.
            </summary>
            <returns>The concrete instantiation of <see cref = "P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />, or
              <see cref = "P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" /> if not a generic method.</returns>
            <remarks>
              In debug builds this can be slower than calling <see cref = "P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.IInvocation.Proceed">
            <summary>
              Proceeds the call to the next interceptor in line, and ultimately to the target method.
            </summary>
            <remarks>
              Since interface proxies without a target don't have the target implementation to proceed to,
              it is important, that the last interceptor does not call this method, otherwise a
              <see cref = "T:System.NotImplementedException" /> will be thrown.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.IInvocation.SetArgumentValue(System.Int32,System.Object)">
            <summary>
              Overrides the value of an argument at the given <paramref name = "index" /> with the
              new <paramref name = "value" /> provided.
            </summary>
            <remarks>
              This method accepts an <see cref = "T:System.Object" />, however the value provided must be compatible
              with the type of the argument defined on the method, otherwise an exception will be thrown.
            </remarks>
            <param name = "index">The index of the argument to override.</param>
            <param name = "value">The new value for the argument.</param>
        </member>
        <member name="M:Castle.DynamicProxy.Internal.AttributeUtil.AddDisassembler``1(Castle.DynamicProxy.IAttributeDisassembler)">
            <summary>
              Registers custom disassembler to handle disassembly of specified type of attributes.
            </summary>
            <typeparam name = "TAttribute">Type of attributes to handle</typeparam>
            <param name = "disassembler">Disassembler converting existing instances of Attributes to CustomAttributeBuilders</param>
            <remarks>
              When disassembling an attribute Dynamic Proxy will first check if an custom disassembler has been registered to handle attributes of that type, 
              and if none is found, it'll use the <see cref = "P:Castle.DynamicProxy.Internal.AttributeUtil.FallbackDisassembler" />.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.Internal.AttributeUtil.ShouldSkipAttributeReplication(System.Type)">
            <summary>
              Attributes should be replicated if they are non-inheritable,
              but there are some special cases where the attributes means
              something to the CLR, where they should be skipped.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsInternal(System.Reflection.MethodBase)">
            <summary>
              Determines whether the specified method is internal.
            </summary>
            <param name = "method">The method.</param>
            <returns>
              <c>true</c> if the specified method is internal; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsInternalToDynamicProxy(System.Reflection.Assembly)">
            <summary>
              Determines whether this assembly has internals visible to dynamic proxy.
            </summary>
            <param name = "asm">The assembly to inspect.</param>
        </member>
        <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsAccessible(System.Reflection.MethodBase)">
            <summary>
              Checks if the method is public or protected.
            </summary>
            <param name = "method"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.DynamicProxy.IProxyBuilder">
            <summary>
              Abstracts the implementation of proxy type construction.
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.IProxyBuilder.Logger">
            <summary>
              Gets or sets the <see cref = "T:Castle.Core.Logging.ILogger" /> that this <see cref = "T:Castle.DynamicProxy.ProxyGenerator" /> logs to.
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope">
            <summary>
              Gets the <see cref = "P:Castle.DynamicProxy.IProxyBuilder.ModuleScope" /> associated with this builder.
            </summary>
            <value>The module scope associated with this builder.</value>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates a proxy type for given <paramref name = "classToProxy" />, implementing <paramref
               name = "additionalInterfacesToProxy" />, using <paramref name = "options" /> provided.
            </summary>
            <param name = "classToProxy">The class type to proxy.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name = "options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
              Implementers should return a proxy type for the specified class and interfaces.
              Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see
               cref = "M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see
               cref = "T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref = "T:Castle.DynamicProxy.Generators.ClassProxyGenerator" />
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates a proxy type that proxies calls to <paramref name = "interfaceToProxy" /> members on <paramref
               name = "targetType" />, implementing <paramref name = "additionalInterfacesToProxy" />, using <paramref
               name = "options" /> provided.
            </summary>
            <param name = "interfaceToProxy">The interface type to proxy.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name = "targetType">Type implementing <paramref name = "interfaceToProxy" /> on which calls to the interface members should be intercepted.</param>
            <param name = "options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
              Implementers should return a proxy type for the specified interface that 'proceeds' executions to the specified target.
              Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see
               cref = "M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see
               cref = "T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref = "T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator" />
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates a proxy type for given <paramref name = "interfaceToProxy" /> and <parmaref
               name = "additionalInterfacesToProxy" /> that delegates all calls to the provided interceptors and allows interceptors to switch the actual target of invocation.
            </summary>
            <param name = "interfaceToProxy">The interface type to proxy.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name = "options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
              Implementers should return a proxy type for the specified interface(s) that delegate all executions to the specified interceptors
              and uses an instance of the interface as their targets (i.e. <see cref = "P:Castle.DynamicProxy.IInvocation.InvocationTarget" />), rather than a class. All <see
               cref = "T:Castle.DynamicProxy.IInvocation" /> classes should then implement <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface,
              to allow interceptors to switch invocation target with instance of another type implementing called interface.
            </remarks>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see
               cref = "T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref = "T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetInterfaceGenerator" />
        </member>
        <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates a proxy type for given <paramref name = "interfaceToProxy" /> that delegates all calls to the provided interceptors.
            </summary>
            <param name = "interfaceToProxy">The interface type to proxy.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types to proxy.</param>
            <param name = "options">The proxy generation options.</param>
            <returns>The generated proxy type.</returns>
            <remarks>
              Implementers should return a proxy type for the specified interface and additional interfaces that delegate all executions to the specified interceptors.
            </remarks>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see
               cref = "T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
            <seealso cref = "T:Castle.DynamicProxy.Generators.InterfaceProxyWithoutTargetGenerator" />
        </member>
        <member name="T:Castle.DynamicProxy.IProxyGenerationHook">
            <summary>
              Used during the target type inspection process. Implementors have a chance to customize the
              proxy generation process.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyGenerationHook.MethodsInspected">
            <summary>
              Invoked by the generation process to notify that the whole process has completed.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyGenerationHook.NonProxyableMemberNotification(System.Type,System.Reflection.MemberInfo)">
            <summary>
              Invoked by the generation process to notify that a member was not marked as virtual.
            </summary>
            <param name = "type">The type which declares the non-virtual member.</param>
            <param name = "memberInfo">The non-virtual member.</param>
            <remarks>
              This method gives an opportunity to inspect any non-proxyable member of a type that has 
              been requested to be proxied, and if appropriate - throw an exception to notify the caller.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyGenerationHook.ShouldInterceptMethod(System.Type,System.Reflection.MethodInfo)">
            <summary>
              Invoked by the generation process to determine if the specified method should be proxied.
            </summary>
            <param name = "type">The type which declares the given method.</param>
            <param name = "methodInfo">The method to inspect.</param>
            <returns>True if the given method should be proxied; false otherwise.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyTargetAccessor.DynProxyGetTarget">
            <summary>
              Get the proxy target (note that null is a valid target!)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.DynamicProxy.IProxyTargetAccessor.GetInterceptors">
            <summary>
              Gets the interceptors for the proxy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.DynamicProxy.MixinData.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
              Because we need to cache the types based on the mixed in mixins, we do the following here:
              - Get all the mixin interfaces
              - Sort them by full name
              - Return them by position
            
            The idea is to have reproducible behavior for the case that mixins are registered in different orders.
            This method is here because it is required 
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.ModuleScope">
            <summary>
              Summary description for ModuleScope.
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME">
            <summary>
              The default file name used when the assembly is saved using <see cref = "F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" />.
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_ASSEMBLY_NAME">
            <summary>
              The default assembly (simple) name used for the assemblies generated by a <see cref = "T:Castle.DynamicProxy.ModuleScope" /> instance.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ModuleScope" /> class; assemblies created by this instance will not be saved.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved.
            </summary>
            <param name = "savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved.
            </summary>
            <param name = "savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
            <param name = "disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean,System.String,System.String,System.String,System.String)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved and what simple names are to be assigned to them.
            </summary>
            <param name = "savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
            <param name = "disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
            <param name = "strongAssemblyName">The simple name of the strong-named assembly generated by this <see
               cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
            <param name = "strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see
               cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
            <param name = "weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
            <param name = "weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see
               cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean,Castle.DynamicProxy.Generators.INamingScope,System.String,System.String,System.String,System.String)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved and what simple names are to be assigned to them.
            </summary>
            <param name = "savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
            <param name = "disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
            <param name = "namingScope">Naming scope used to provide unique names to generated types and their members (usually via sub-scopes).</param>
            <param name = "strongAssemblyName">The simple name of the strong-named assembly generated by this <see
               cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
            <param name = "strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see
               cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
            <param name = "weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
            <param name = "weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see
               cref = "T:Castle.DynamicProxy.ModuleScope" />.</param>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.Lock">
            <summary>
              Users of this <see cref = "T:Castle.DynamicProxy.ModuleScope" /> should use this lock when accessing the cache.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.GetFromCache(Castle.DynamicProxy.Generators.CacheKey)">
            <summary>
              Returns a type from this scope's type cache, or null if the key cannot be found.
            </summary>
            <param name = "key">The key to be looked up in the cache.</param>
            <returns>The type from this scope's type cache matching the key, or null if the key cannot be found</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.RegisterInCache(Castle.DynamicProxy.Generators.CacheKey,System.Type)">
            <summary>
              Registers a type in this scope's type cache.
            </summary>
            <param name = "key">The key to be associated with the type.</param>
            <param name = "type">The type to be stored in the cache.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.GetKeyPair">
            <summary>
              Gets the key pair used to sign the strong-named assembly generated by this <see cref = "T:Castle.DynamicProxy.ModuleScope" />.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule">
            <summary>
              Gets the strong-named module generated by this scope, or <see langword = "null" /> if none has yet been generated.
            </summary>
            <value>The strong-named module generated by this scope, or <see langword = "null" /> if none has yet been generated.</value>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleName">
            <summary>
              Gets the file name of the strongly named module generated by this scope.
            </summary>
            <value>The file name of the strongly named module generated by this scope.</value>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleDirectory">
            <summary>
              Gets the directory where the strongly named module generated by this scope will be saved, or <see langword = "null" /> if the current directory
              is used.
            </summary>
            <value>The directory where the strongly named module generated by this scope will be saved when <see
               cref = "M:Castle.DynamicProxy.ModuleScope.SaveAssembly" /> is called
              (if this scope was created to save modules).</value>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule">
            <summary>
              Gets the weak-named module generated by this scope, or <see langword = "null" /> if none has yet been generated.
            </summary>
            <value>The weak-named module generated by this scope, or <see langword = "null" /> if none has yet been generated.</value>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleName">
            <summary>
              Gets the file name of the weakly named module generated by this scope.
            </summary>
            <value>The file name of the weakly named module generated by this scope.</value>
        </member>
        <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleDirectory">
            <summary>
              Gets the directory where the weakly named module generated by this scope will be saved, or <see langword = "null" /> if the current directory
              is used.
            </summary>
            <value>The directory where the weakly named module generated by this scope will be saved when <see
               cref = "M:Castle.DynamicProxy.ModuleScope.SaveAssembly" /> is called
              (if this scope was created to save modules).</value>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModule(System.Boolean)">
            <summary>
              Gets the specified module generated by this scope, creating a new one if none has yet been generated.
            </summary>
            <param name = "isStrongNamed">If set to true, a strong-named module is returned; otherwise, a weak-named module is returned.</param>
            <returns>A strong-named or weak-named module generated by this scope, as specified by the <paramref
               name = "isStrongNamed" /> parameter.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithStrongName">
            <summary>
              Gets the strong-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
            <returns>A strong-named module generated by this scope.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithWeakName">
            <summary>
              Gets the weak-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
            <returns>A weak-named module generated by this scope.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly">
            <summary>
              Saves the generated assembly with the name and directory information given when this <see cref = "T:Castle.DynamicProxy.ModuleScope" /> instance was created (or with
              the <see cref = "F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" /> and current directory if none was given).
            </summary>
            <remarks>
              <para>
                This method stores the generated assembly in the directory passed as part of the module information specified when this instance was
                constructed (if any, else the current directory is used). If both a strong-named and a weak-named assembly
                have been generated, it will throw an exception; in this case, use the <see cref = "M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)" /> overload.
              </para>
              <para>
                If this <see cref = "T:Castle.DynamicProxy.ModuleScope" /> was created without indicating that the assembly should be saved, this method does nothing.
              </para>
            </remarks>
            <exception cref = "T:System.InvalidOperationException">Both a strong-named and a weak-named assembly have been generated.</exception>
            <returns>The path of the generated assembly file, or null if no file has been generated.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)">
            <summary>
              Saves the specified generated assembly with the name and directory information given when this <see
               cref = "T:Castle.DynamicProxy.ModuleScope" /> instance was created
              (or with the <see cref = "F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" /> and current directory if none was given).
            </summary>
            <param name = "strongNamed">True if the generated assembly with a strong name should be saved (see <see
               cref = "P:Castle.DynamicProxy.ModuleScope.StrongNamedModule" />);
              false if the generated assembly without a strong name should be saved (see <see cref = "P:Castle.DynamicProxy.ModuleScope.WeakNamedModule" />.</param>
            <remarks>
              <para>
                This method stores the specified generated assembly in the directory passed as part of the module information specified when this instance was
                constructed (if any, else the current directory is used).
              </para>
              <para>
                If this <see cref = "T:Castle.DynamicProxy.ModuleScope" /> was created without indicating that the assembly should be saved, this method does nothing.
              </para>
            </remarks>
            <exception cref = "T:System.InvalidOperationException">No assembly has been generated that matches the <paramref
               name = "strongNamed" /> parameter.
            </exception>
            <returns>The path of the generated assembly file, or null if no file has been generated.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ModuleScope.LoadAssemblyIntoCache(System.Reflection.Assembly)">
            <summary>
              Loads the generated types from the given assembly into this <see cref = "T:Castle.DynamicProxy.ModuleScope" />'s cache.
            </summary>
            <param name = "assembly">The assembly to load types from. This assembly must have been saved via <see
               cref = "M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)" /> or
              <see cref = "M:Castle.DynamicProxy.ModuleScope.SaveAssembly" />, or it must have the <see cref = "T:Castle.DynamicProxy.Serialization.CacheMappingsAttribute" /> manually applied.</param>
            <remarks>
              This method can be used to load previously generated and persisted proxy types from disk into this scope's type cache, eg. in order
              to avoid the performance hit associated with proxy generation.
            </remarks>
        </member>
        <member name="T:Castle.DynamicProxy.PersistentProxyBuilder">
            <summary>
              ProxyBuilder that persists the generated type.
            </summary>
            <remarks>
              The saved assembly contains just the last generated type.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.PersistentProxyBuilder" /> class.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.SaveAssembly">
            <summary>
              Saves the generated assembly to a physical file. Note that this renders the <see cref = "T:Castle.DynamicProxy.PersistentProxyBuilder" /> unusable.
            </summary>
            <returns>The path of the generated assembly file, or null if no assembly has been generated.</returns>
            <remarks>
              This method does not support saving multiple files. If both a signed and an unsigned module have been generated, use the 
              respective methods of the <see cref = "T:Castle.DynamicProxy.ModuleScope" />.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor(Castle.DynamicProxy.IProxyGenerationHook)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
            <param name = "hook">The hook.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.ProxyGenerator">
            <summary>
              Provides proxy objects for classes and interfaces.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(Castle.DynamicProxy.IProxyBuilder)">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
            <param name = "builder">Proxy types builder.</param>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.ProxyGenerator.Logger">
            <summary>
              Gets or sets the <see cref = "T:Castle.Core.Logging.ILogger" /> that this <see cref = "T:Castle.DynamicProxy.ProxyGenerator" /> log to.
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.ProxyGenerator.ProxyBuilder">
            <summary>
              Gets the proxy builder instance used to generate proxy types.
            </summary>
            <value>The proxy builder.</value>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</typeparam>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>Object proxying calls to members of <typeparamref name = "TInterface" /> on <paramref name = "target" /> object.</returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" />is not an interface type.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method generates new proxy type for each type of <paramref name = "target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref = "M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</typeparam>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <typeparamref name = "TInterface" /> on <paramref name = "target" /> object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" />is not an interface type.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method generates new proxy type for each type of <paramref name = "target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see
               cref = "M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> type on <paramref name = "target" /> object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method generates new proxy type for each type of <paramref name = "target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref = "M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> type on <paramref name = "target" /> object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method generates new proxy type for each type of <paramref name = "target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref = "M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> and <paramref
               name = "additionalInterfacesToProxy" /> types  on <paramref name = "target" /> object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method generates new proxy type for each type of <paramref name = "target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref = "M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> and <paramref
               name = "additionalInterfacesToProxy" /> types on <paramref name = "target" /> object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method generates new proxy type for each type of <paramref name = "target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref = "M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
              Interceptors can use <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref
               name = "target" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> type on <paramref name = "target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
              Interceptors can use <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref
               name = "target" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</typeparam>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <typeparamref name = "TInterface" /> type on <paramref name = "target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" /> is not an interface type.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
              Interceptors can use <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref
               name = "target" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</typeparam>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <typeparamref name = "TInterface" /> type on <paramref name = "target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" /> is not an interface type.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
              Interceptors can use <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref
               name = "target" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> and <paramref
               name = "additionalInterfacesToProxy" /> types on <paramref name = "target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref
               name = "target" /> object with given <paramref name = "interceptors" />.
              Interceptors can use <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref
               name = "target" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> type on <paramref name = "target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref
               name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref
               name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref
               name = "target" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on <paramref name = "target" /> object with given <paramref name = "interceptors" />.
              Interceptors can use <see cref = "T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name = "target" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface implemented by <paramref name = "target" /> which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types on <paramref name = "target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "target" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> or any of <paramref name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "target" /> does not implement <paramref name = "interfaceToProxy" /> interface.</exception>
            <exception cref = "T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name = "target" /> object.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name = "target" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.IInterceptor)">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on target object generated at runtime with given <paramref
               name = "interceptor" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface which will be proxied.</typeparam>
            <param name = "interceptor">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <typeparamref name = "TInterface" /> types on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptor" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref = "T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on target object generated at runtime with given <paramref
               name = "interceptors" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface which will be proxied.</typeparam>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <typeparamref name = "TInterface" /> types on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref = "T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name = "TInterface" /> on target object generated at runtime with given <paramref
               name = "interceptors" />.
            </summary>
            <typeparam name = "TInterface">Type of the interface which will be proxied.</typeparam>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <typeparamref name = "TInterface" /> types on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TInterface" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref = "T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.IInterceptor)">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on target object generated at runtime with given <paramref
               name = "interceptor" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name = "interceptor">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> type on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptor" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on target object generated at runtime with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> type on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on target object generated at runtime with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> and <paramref
               name = "additionalInterfacesToProxy" /> types on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on target object generated at runtime with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" />  is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <remarks>
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to members of interface <paramref name = "interfaceToProxy" /> on target object generated at runtime with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "interfaceToProxy">Type of the interface which will be proxied.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              Object proxying calls to members of <paramref name = "interfaceToProxy" /> and <paramref
               name = "additionalInterfacesToProxy" /> types on generated target object.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "interfaceToProxy" /> is not an interface type.</exception>
            <remarks>
              Since this method uses an empty-shell implementation of <paramref name = "additionalInterfacesToProxy" /> to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see
               cref = "T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see
               cref = "M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget``1(``0,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name = "TClass" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <typeparam name = "TClass">Type of class which will be proxied.</typeparam>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <typeparamref name = "TClass" /> proxying calls to virtual members of <typeparamref
               name = "TClass" /> type.
            </returns>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TClass" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name = "TClass" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name = "TClass" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name = "TClass" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <typeparam name = "TClass">Type of class which will be proxied.</typeparam>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <typeparamref name = "TClass" /> proxying calls to virtual members of <typeparamref
               name = "TClass" /> type.
            </returns>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TClass" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name = "TClass" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name = "TClass" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "constructorArguments">Arguments of constructor of type <paramref name = "classToProxy" /> which should be used to create a new instance of that type.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no constructor exists on type <paramref name = "classToProxy" /> with parameters matching <paramref
               name = "constructorArguments" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,System.Object[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "constructorArguments">Arguments of constructor of type <paramref name = "classToProxy" /> which should be used to create a new instance of that type.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no constructor exists on type <paramref name = "classToProxy" /> with parameters matching <paramref
               name = "constructorArguments" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no parameterless constructor exists on type <paramref
               name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "options" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "options" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "target">The target object, calls to which will be intercepted.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "constructorArguments">Arguments of constructor of type <paramref name = "classToProxy" /> which should be used to create a new instance of that type.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "options" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no constructor exists on type <paramref name = "classToProxy" /> with parameters matching <paramref
               name = "constructorArguments" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name = "TClass" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <typeparam name = "TClass">Type of class which will be proxied.</typeparam>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <typeparamref name = "TClass" /> proxying calls to virtual members of <typeparamref
               name = "TClass" /> type.
            </returns>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TClass" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name = "TClass" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name = "TClass" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name = "TClass" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <typeparam name = "TClass">Type of class which will be proxied.</typeparam>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <typeparamref name = "TClass" /> proxying calls to virtual members of <typeparamref
               name = "TClass" /> type.
            </returns>
            <exception cref = "T:System.ArgumentException">Thrown when given <typeparamref name = "TClass" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name = "TClass" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name = "TClass" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "constructorArguments">Arguments of constructor of type <paramref name = "classToProxy" /> which should be used to create a new instance of that type.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no constructor exists on type <paramref name = "classToProxy" /> with parameters matching <paramref
               name = "constructorArguments" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Object[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "constructorArguments">Arguments of constructor of type <paramref name = "classToProxy" /> which should be used to create a new instance of that type.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no constructor exists on type <paramref name = "classToProxy" /> with parameters matching <paramref
               name = "constructorArguments" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no parameterless constructor exists on type <paramref
               name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> type.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "options" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "options" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name = "classToProxy" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
            <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name = "classToProxy" /> on newly created instance of that type with given <paramref
               name = "interceptors" />.
            </summary>
            <param name = "classToProxy">Type of class which will be proxied.</param>
            <param name = "additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
            <param name = "options">The proxy generation options used to influence generated proxy type and object.</param>
            <param name = "constructorArguments">Arguments of constructor of type <paramref name = "classToProxy" /> which should be used to create a new instance of that type.</param>
            <param name = "interceptors">The interceptors called during the invocation of proxied methods.</param>
            <returns>
              New object of type <paramref name = "classToProxy" /> proxying calls to virtual members of <paramref
               name = "classToProxy" /> and <paramref name = "additionalInterfacesToProxy" /> types.
            </returns>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentNullException">Thrown when given <paramref name = "options" /> object is a null reference (Nothing in Visual Basic).</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> or any of <paramref
               name = "additionalInterfacesToProxy" /> is a generic type definition.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when given <paramref name = "classToProxy" /> is not a class type.</exception>
            <exception cref = "T:System.ArgumentException">Thrown when no constructor exists on type <paramref name = "classToProxy" /> with parameters matching <paramref
               name = "constructorArguments" />.</exception>
            <exception cref = "T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name = "classToProxy" /> throws an exception.</exception>
            <remarks>
              This method uses <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref = "T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates the proxy type for class proxy with given <paramref name = "classToProxy" /> class, implementing given <paramref
               name = "additionalInterfacesToProxy" /> and using provided <paramref name = "options" />.
            </summary>
            <param name = "classToProxy">The base class for proxy type.</param>
            <param name = "additionalInterfacesToProxy">The interfaces that proxy type should implement.</param>
            <param name = "options">The options for proxy generation process.</param>
            <returns><see cref = "T:System.Type" /> of proxy.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates the proxy type for interface proxy with target for given <paramref name = "interfaceToProxy" /> interface, implementing given <paramref
               name = "additionalInterfacesToProxy" /> on given <paramref name = "targetType" /> and using provided <paramref
               name = "options" />.
            </summary>
            <param name = "interfaceToProxy">The interface proxy type should implement.</param>
            <param name = "additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
            <param name = "targetType">Actual type that the proxy type will encompass.</param>
            <param name = "options">The options for proxy generation process.</param>
            <returns><see cref = "T:System.Type" /> of proxy.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates the proxy type for interface proxy with target interface for given <paramref name = "interfaceToProxy" /> interface, implementing given <paramref
               name = "additionalInterfacesToProxy" /> on given <paramref name = "interfaceToProxy" /> and using provided <paramref
               name = "options" />.
            </summary>
            <param name = "interfaceToProxy">The interface proxy type should implement.</param>
            <param name = "additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
            <param name = "options">The options for proxy generation process.</param>
            <returns><see cref = "T:System.Type" /> of proxy.</returns>
        </member>
        <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
            <summary>
              Creates the proxy type for interface proxy without target for given <paramref name = "interfaceToProxy" /> interface, implementing given <paramref
               name = "additionalInterfacesToProxy" /> and using provided <paramref name = "options" />.
            </summary>
            <param name = "interfaceToProxy">The interface proxy type should implement.</param>
            <param name = "additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
            <param name = "options">The options for proxy generation process.</param>
            <returns><see cref = "T:System.Type" /> of proxy.</returns>
        </member>
        <member name="T:Castle.DynamicProxy.Serialization.CacheMappingsAttribute">
            <summary>
              Applied to the assemblies saved by <see cref = "T:Castle.DynamicProxy.ModuleScope" /> in order to persist the cache data included in the persisted assembly.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Serialization.ProxyObjectReference">
            <summary>
              Handles the deserialization of proxies.
            </summary>
        </member>
        <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope">
            <summary>
              Resets the <see cref = "P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization to a new scope.
            </summary>
            <remarks>
              This is useful for test cases.
            </remarks>
        </member>
        <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.SetScope(Castle.DynamicProxy.ModuleScope)">
            <summary>
              Resets the <see cref = "P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization to a given <paramref name = "scope" />.
            </summary>
            <param name = "scope">The scope to be used for deserialization.</param>
            <remarks>
              By default, the deserialization process uses a different scope than the rest of the application, which can lead to multiple proxies
              being generated for the same type. By explicitly setting the deserialization scope to the application's scope, this can be avoided.
            </remarks>
        </member>
        <member name="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope">
            <summary>
              Gets the <see cref = "P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization.
            </summary>
            <value>As <see cref = "T:Castle.DynamicProxy.Serialization.ProxyObjectReference" /> has no way of automatically determining the scope used by the application (and the application
              might use more than one scope at the same time), <see cref = "T:Castle.DynamicProxy.Serialization.ProxyObjectReference" /> uses a dedicated scope instance for deserializing proxy
              types. This instance can be reset and set to a specific value via <see cref = "M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope" /> and <see
               cref = "M:Castle.DynamicProxy.Serialization.ProxyObjectReference.SetScope(Castle.DynamicProxy.ModuleScope)" />.</value>
        </member>
        <member name="M:Castle.DynamicProxy.Serialization.RemotableInvocation.Proceed">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Castle.DynamicProxy.Serialization.RemotableInvocation.Method">
            <summary>
            </summary>
        </member>
        <member name="P:Castle.DynamicProxy.Serialization.RemotableInvocation.MethodInvocationTarget">
            <summary>
              For interface proxies, this will point to the
              <see cref = "T:System.Reflection.MethodInfo" /> on the target class
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Tokens.InvocationMethods">
            <summary>
              Holds <see cref = "T:System.Reflection.MethodInfo" /> objects representing methods of <see cref = "T:Castle.DynamicProxy.AbstractInvocation" /> class.
            </summary>
        </member>
        <member name="T:Castle.DynamicProxy.Tokens.SerializationInfoMethods">
            <summary>
              Holds <see cref = "T:System.Reflection.MethodInfo" /> objects representing methods of <see cref = "T:System.Runtime.Serialization.SerializationInfo" /> class.
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Bool">
            <summary>
              <see cref = "M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Boolean)" />
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Int32">
            <summary>
              <see cref = "M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Int32)" />
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Object">
            <summary>
              <see cref = "M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Object)" />
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.GetValue">
            <summary>
              <see cref = "M:System.Runtime.Serialization.SerializationInfo.GetValue(System.String,System.Type)" />
            </summary>
        </member>
        <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.SetType">
            <summary>
              <see cref = "M:System.Runtime.Serialization.SerializationInfo.SetType(System.Type)" />
            </summary>
        </member>
    </members>
</doc>
